# å¼•æ“æ¨¡å—è¯¦è§£ - Engine Modules Documentation

## æ¦‚è¿°

Game Macroçš„å¼•æ“æ¨¡å—æ˜¯æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒå¤„ç†å•å…ƒï¼Œè´Ÿè´£å®ç°å„ç§è‡ªåŠ¨åŒ–åŠŸèƒ½ã€‚å¼•æ“æ¨¡å—é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼Œæ¯ä¸ªå¼•æ“è´Ÿè´£ç‰¹å®šçš„åŠŸèƒ½é¢†åŸŸï¼Œé€šè¿‡åè°ƒé…åˆå®ç°å¤æ‚çš„æ¸¸æˆè‡ªåŠ¨åŒ–æ“ä½œã€‚

## å¼•æ“æ¶æ„æ¦‚è§ˆ

### æ ¸å¿ƒå¼•æ“åˆ—è¡¨

1. **Rotation.ahk** - æŠ€èƒ½è½®æ¢å¼•æ“ï¼ˆé«˜çº§æ—‹è½¬ç³»ç»Ÿï¼‰
2. **RuleEngine.ahk** - è§„åˆ™å¼•æ“ï¼ˆæ¡ä»¶åˆ¤æ–­å’ŒåŠ¨ä½œæ‰§è¡Œï¼‰
3. **BuffEngine.ahk** - Buffç»­æ—¶å¼•æ“ï¼ˆæ™ºèƒ½BUFFç®¡ç†ï¼‰
4. **Dup.ahk** - å±å¹•æ•è·å¼•æ“ï¼ˆDXGIé«˜æ€§èƒ½æ•è·ï¼‰
5. **Pixel.ahk** - åƒç´ æ£€æµ‹å¼•æ“ï¼ˆROIæ£€æµ‹å’ŒGDIå¤‡ç”¨ï¼‰
6. **Poller.ahk** - è½®è¯¢è°ƒåº¦å¼•æ“ï¼ˆå¤šçº¿ç¨‹è°ƒåº¦ï¼‰
7. **RuleEngine_Core.ahk** - è§„åˆ™å¼•æ“æ ¸å¿ƒé€»è¾‘
8. **RuleEngine_Util.ahk** - è§„åˆ™å¼•æ“å·¥å…·åˆ¤å®šå‡½æ•°
9. **RuleEngine_Log.ahk** - è§„åˆ™å¼•æ“æ—¥å¿—åŠŸèƒ½
10. **Rotation_State.ahk** - æ—‹è½¬çŠ¶æ€ç®¡ç†

### å¼•æ“åä½œå…³ç³»

```
Poller (è½®è¯¢è°ƒåº¦)
    â”œâ”€â”€ Dup (å±å¹•æ•è·)
    â”œâ”€â”€ Pixel (åƒç´ æ£€æµ‹)
    â”œâ”€â”€ BuffEngine (Buffç»­æ—¶)
    â””â”€â”€ Rotation/RuleEngine (æŠ€èƒ½é‡Šæ”¾)
         â””â”€â”€ WorkerPool (æŒ‰é”®å‘é€)
```

## 1. æŠ€èƒ½è½®æ¢å¼•æ“ - Rotation.ahk

### æ ¸å¿ƒåŠŸèƒ½

æŠ€èƒ½è½®æ¢å¼•æ“æ˜¯æ¸¸æˆè‡ªåŠ¨åŒ–ä¸­æœ€å¤æ‚çš„ç»„ä»¶ä¹‹ä¸€ï¼Œè´Ÿè´£ç®¡ç†å¤æ‚çš„æŠ€èƒ½é‡Šæ”¾åºåˆ—ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **å¤šè½¨é“è½®æ¢**: æ”¯æŒå®šä¹‰å¤šä¸ªæŠ€èƒ½è½¨é“ï¼ˆTracksï¼‰
- **Gateæ¡ä»¶ç³»ç»Ÿ**: åŸºäºæ¡ä»¶çš„æ™ºèƒ½è·³è½¨åŠŸèƒ½
- **èµ·æ‰‹æŠ€èƒ½**: ä¸“é—¨çš„èµ·æ‰‹æŠ€èƒ½å¤„ç†
- **é˜²æŠ–æœºåˆ¶**: é˜²æ­¢æŠ€èƒ½é¢‘ç¹è§¦å‘
- **BusyWindow**: æ£€æµ‹å’Œé¿å…çª—å£å¿™ç¢ŒçŠ¶æ€

### æ ¸å¿ƒæ•°æ®ç»“æ„

```autohotkey
; è½®æ¢é…ç½®ç»“æ„
Rotation := {
    Tracks: [],           // è½¨é“æ•°ç»„
    CurrentTrack: 1,      // å½“å‰è½¨é“ç´¢å¼•
    GateConditions: [],   // Gateæ¡ä»¶åˆ—è¡¨
    BlackBox: {           // é»‘æ¡†é…ç½®
        X: 0,
        Y: 0, 
        Width: 100,
        Height: 50,
        Enabled: true
    },
    BusyWindow: {         // å¿™ç¢Œçª—å£é…ç½®
        MinDelay: 100,
        MaxDelay: 500
    }
}

; æŠ€èƒ½æ•°æ®ç»“æ„
SkillData := {
    Index: 1,             // æŠ€èƒ½ç´¢å¼•
    Name: "æŠ€èƒ½åç§°",      // æŠ€èƒ½åç§°
    Key: "Q",             // æŒ‰é”®
    Enabled: true,        // æ˜¯å¦å¯ç”¨
    Track: 1,            // æ‰€å±è½¨é“
    CastMs: 500,         // æ–½æ³•æ—¶é—´
    HoldMs: 100,         // æŒ‰é”®æŒç»­æ—¶é—´
    CooldownMs: 1000     // å†·å´æ—¶é—´
}
```

### æ ¸å¿ƒå‡½æ•°

#### åˆå§‹åŒ–å‡½æ•°

**Rotation_InitFromProfile()**
```autohotkey
; ä»é…ç½®æ–‡ä»¶åˆå§‹åŒ–è½®æ¢å¼•æ“
Rotation_InitFromProfile() {
    global App, Rotation
    
    ; è¯»å–é…ç½®æ–‡ä»¶ä¸­çš„è½®æ¢è®¾ç½®
    if App.Has("ProfileData") && App["ProfileData"].Has("Rotation") {
        rot := App["ProfileData"]["Rotation"]
        
        ; åˆå§‹åŒ–è½¨é“
        if rot.Has("Tracks") {
            Rotation.Tracks := rot["Tracks"]
        }
        
        ; åˆå§‹åŒ–Gateæ¡ä»¶
        if rot.Has("GateConditions") {
            Rotation.GateConditions := rot["GateConditions"]
        }
        
        ; åˆå§‹åŒ–é»‘æ¡†æ£€æµ‹
        if rot.Has("BlackBox") {
            Rotation.BlackBox := rot["BlackBox"]
        }
    }
    
    ; è®¾ç½®é»˜è®¤è½¨é“
    Rotation.CurrentTrack := 1
}
```

#### è½®æ¢æ§åˆ¶å‡½æ•°

**Rotation_Reset()**
```autohotkey
; é‡ç½®è½®æ¢çŠ¶æ€
Rotation_Reset() {
    global Rotation
    Rotation.CurrentTrack := 1
    ; é‡ç½®ç›¸å…³çŠ¶æ€
    ; ...
}
```

**Rotation_GetNextSkill()**
```autohotkey
; è·å–ä¸‹ä¸€ä¸ªæŠ€èƒ½
Rotation_GetNextSkill() {
    global App, Rotation
    
    if !Rotation.Tracks.Length()
        return 0
    
    track := Rotation.Tracks[Rotation.CurrentTrack]
    
    ; æ£€æŸ¥Gateæ¡ä»¶
    if Rotation_CheckGateConditions(track) {
        Rotation_SwitchToNextTrack()
        track := Rotation.Tracks[Rotation.CurrentTrack]
    }
    
    ; ä»å½“å‰è½¨é“è·å–æŠ€èƒ½
    return Rotation_GetSkillFromTrack(track)
}
```

#### Gateæ¡ä»¶ç³»ç»Ÿ

**Rotation_CheckGateConditions()**
```autohotkey
; æ£€æŸ¥æ˜¯å¦æ»¡è¶³è·³è½¨æ¡ä»¶
Rotation_CheckGateConditions(track) {
    global Rotation, Pixel
    
    if !Rotation.GateConditions.Length()
        return false
    
    for condition in Rotation.GateConditions {
        ; æ£€æŸ¥æ¡ä»¶ç±»å‹
        switch condition.Type {
            case "PixelColor":
                color := Pixel_GetPixelColor(condition.X, condition.Y)
                if (color == condition.ExpectedColor) {
                    return true
                }
            case "SkillCooldown":
                ; æ£€æŸ¥æŠ€èƒ½å†·å´çŠ¶æ€
                if (Skill_IsReady(condition.SkillIndex)) {
                    return true
                }
        }
    }
    return false
}
```

### è½¨é“ç®¡ç†

**è½¨é“åˆ‡æ¢é€»è¾‘**:
```autohotkey
Rotation_SwitchToNextTrack() {
    global Rotation
    
    Rotation.CurrentTrack++
    if (Rotation.CurrentTrack > Rotation.Tracks.Length()) {
        Rotation.CurrentTrack := 1
    }
    
    ; è®°å½•åˆ‡æ¢æ—¥å¿—
    Rotation_Log("Switched to track: " Rotation.CurrentTrack)
}
```

### é˜²æŠ–æœºåˆ¶

**é»‘æ¡†æ£€æµ‹**:
```autohotkey
Rotation_CheckBlackBox() {
    global Rotation, Pixel
    
    if !Rotation.BlackBox.Enabled
        return true
    
    ; æ£€æµ‹é»‘æ¡†åŒºåŸŸ
    color := Pixel_GetAverageColor(
        Rotation.BlackBox.X,
        Rotation.BlackBox.Y,
        Rotation.BlackBox.Width,
        Rotation.BlackBox.Height
    )
    
    ; å¦‚æœæ˜¯é»‘è‰²ï¼ˆæˆ–å…¶ä»–æŒ‡å®šé¢œè‰²ï¼‰ï¼Œè®¤ä¸ºå¤„äºé˜²æŠ–çŠ¶æ€
    return (color != 0x000000)
}
```

## 2. è§„åˆ™å¼•æ“ - RuleEngine.ahk

### æ ¸å¿ƒåŠŸèƒ½

è§„åˆ™å¼•æ“æä¾›çµæ´»çš„åŸºäºæ¡ä»¶çš„æŠ€èƒ½é‡Šæ”¾ç³»ç»Ÿï¼Œæ”¯æŒå¤æ‚çš„æ¡ä»¶åˆ¤æ–­å’ŒåŠ¨ä½œæ‰§è¡Œã€‚

**ä¸»è¦ç‰¹æ€§**:
- **æ¡ä»¶åˆ¤æ–­**: æ”¯æŒåƒç´ é¢œè‰²ã€æŠ€èƒ½å†·å´ç­‰å¤šç§æ¡ä»¶
- **è§„åˆ™è¿‡æ»¤**: çµæ´»çš„è§„åˆ™å¯ç”¨/ç¦ç”¨æ§åˆ¶
- **è®¡æ•°æ¨¡å¼**: åŸºäºæŠ€èƒ½ä½¿ç”¨æ¬¡æ•°çš„è§„åˆ™è§¦å‘
- **è°ƒè¯•æ—¥å¿—**: è¯¦ç»†çš„æ‰§è¡Œæ—¥å¿—å’Œå±å¹•æç¤º
- **å›æ‰§æ ¡éªŒ**: æŠ€èƒ½å‘é€æˆåŠŸéªŒè¯

### æ•°æ®ç»“æ„

```autohotkey
; è§„åˆ™ç»“æ„
Rule := {
    ID: "rule_001",           // è§„åˆ™å”¯ä¸€æ ‡è¯†
    Name: "å›è¡€æŠ€èƒ½è§„åˆ™",       // è§„åˆ™åç§°
    Enabled: true,            // æ˜¯å¦å¯ç”¨
    ThreadId: 1,             // æ‰€å±çº¿ç¨‹
    Conditions: [],          // æ¡ä»¶åˆ—è¡¨
    Actions: [],             // åŠ¨ä½œåˆ—è¡¨
    CountMode: false,        // æ˜¯å¦å¯ç”¨è®¡æ•°æ¨¡å¼
    TriggerCount: 5,         // è§¦å‘è®¡æ•°
    CooldownMs: 1000,        // å†·å´æ—¶é—´
    LastTriggerTime: 0       // ä¸Šæ¬¡è§¦å‘æ—¶é—´
}

; æ¡ä»¶ç»“æ„
Condition := {
    Type: "PixelColor",      // æ¡ä»¶ç±»å‹
    X: 100,                  // Xåæ ‡
    Y: 200,                  // Yåæ ‡
    ExpectedColor: "0xFF0000", // æœŸæœ›é¢œè‰²
    Tolerance: 10,           // é¢œè‰²å®¹å·®
    Description: "è¡€é‡æ£€æµ‹ç‚¹"  // æ¡ä»¶æè¿°
}

; åŠ¨ä½œç»“æ„
Action := {
    Type: "UseSkill",        // åŠ¨ä½œç±»å‹
    SkillIndex: 1,           // æŠ€èƒ½ç´¢å¼•
    Key: "Q",               // æŒ‰é”®
    HoldMs: 100,            // æŒ‰é”®æŒç»­æ—¶é—´
    Description: "é‡Šæ”¾å›è¡€æŠ€èƒ½" // åŠ¨ä½œæè¿°
}
```

### æ ¸å¿ƒå‡½æ•°

#### è§„åˆ™æ‰§è¡Œ

**RuleEngine_RunTick()**
```autohotkey
; è§„åˆ™å¼•æ“ä¸»å¾ªç¯
RuleEngine_RunTick() {
    global App, RuleEngine
    
    if !RuleEngine.Rules.Length()
        return
    
    ; éå†æ‰€æœ‰è§„åˆ™
    for rule in RuleEngine.Rules {
        if !rule.Enabled
            continue
        
        ; æ£€æŸ¥å†·å´æ—¶é—´
        if RuleEngine_CheckCooldown(rule)
            continue
        
        ; æ£€æŸ¥æ¡ä»¶
        if RuleEngine_CheckConditions(rule) {
            ; æ‰§è¡ŒåŠ¨ä½œ
            RuleEngine_ExecuteActions(rule)
            
            ; æ›´æ–°è§¦å‘æ—¶é—´
            rule.LastTriggerTime := A_TickCount
            
            ; è®°å½•æ—¥å¿—
            RuleEngine_Log(rule.Name " è§„åˆ™è§¦å‘")
        }
    }
}
```

#### æ¡ä»¶æ£€æŸ¥

**RuleEngine_CheckConditions()**
```autohotkey
; æ£€æŸ¥è§„åˆ™æ¡ä»¶
RuleEngine_CheckConditions(rule) {
    for condition in rule.Conditions {
        if !RuleEngine_CheckSingleCondition(condition) {
            return false
        }
    }
    return true
}

RuleEngine_CheckSingleCondition(condition) {
    switch condition.Type {
        case "PixelColor":
            return RuleEngine_CheckPixelColor(condition)
        case "SkillCooldown":
            return RuleEngine_CheckSkillCooldown(condition)
        case "HPPercent":
            return RuleEngine_CheckHPPercent(condition)
        case "MPPercent":
            return RuleEngine_CheckMPPercent(condition)
    }
    return false
}
```

**åƒç´ é¢œè‰²æ£€æŸ¥**:
```autohotkey
RuleEngine_CheckPixelColor(condition) {
    global Pixel
    
    actualColor := Pixel_GetPixelColor(condition.X, condition.Y)
    expectedColor := condition.ExpectedColor
    
    ; è®¡ç®—é¢œè‰²å·®å¼‚
    diff := Pixel_CalculateColorDiff(actualColor, expectedColor)
    
    return (diff <= condition.Tolerance)
}
```

#### åŠ¨ä½œæ‰§è¡Œ

**RuleEngine_ExecuteActions()**
```autohotkey
; æ‰§è¡Œè§„åˆ™åŠ¨ä½œ
RuleEngine_ExecuteActions(rule) {
    for action in rule.Actions {
        switch action.Type {
            case "UseSkill":
                WorkerPool_SendSkillIndex(rule.ThreadId, action.SkillIndex, "Rule:" rule.ID)
            case "SendKey":
                WorkerPool_FireAndForget(action.Key)
        }
    }
}
```

### è®¡æ•°æ¨¡å¼

**è®¡æ•°åŠŸèƒ½**:
```autohotkey
RuleEngine_CheckCountMode(rule) {
    if !rule.CountMode
        return true
    
    ; æ£€æŸ¥å„æŠ€èƒ½çš„è§¦å‘æ¬¡æ•°
    for condition in rule.Conditions {
        if condition.Type == "UseSkill" {
            count := Counters_Get(condition.SkillIndex)
            if (count >= rule.TriggerCount) {
                return true
            }
        }
    }
    return false
}
```

## 3. Buffç»­æ—¶å¼•æ“ - BuffEngine.ahk

### æ ¸å¿ƒåŠŸèƒ½

BuffEngineä¸“é—¨è´Ÿè´£ç®¡ç†æ¸¸æˆçš„Buffç»­æ—¶åŠŸèƒ½ï¼Œç¡®ä¿é‡è¦å¢ç›Šæ•ˆæœä¸ä¼šä¸­æ–­ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **ä¼˜å…ˆç»­æ—¶**: æ™ºèƒ½çš„Buffä¼˜å…ˆçº§ç®¡ç†
- **å¤šçº¿ç¨‹**: æ”¯æŒå¤šçº¿ç¨‹å¹¶å‘å¤„ç†
- **æŠ€èƒ½æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹æŠ€èƒ½å°±ç»ªçŠ¶æ€
- **è®¡æ—¶ç²¾ç¡®**: ç²¾ç¡®çš„BuffæŒç»­æ—¶é—´ç®¡ç†
- **ç»­æ—¶é¢„æµ‹**: æå‰é¢„æµ‹Buffåˆ°æœŸæ—¶é—´

### æ•°æ®ç»“æ„

```autohotkey
; Buffé…ç½®
BuffConfig := {
    ID: "buff_001",          // Buffæ ‡è¯†
    Name: "åŠ›é‡å¢å¼º",         // Buffåç§°
    SkillIndex: 1,          // å¯¹åº”æŠ€èƒ½ç´¢å¼•
    DurationMs: 30000,      // æŒç»­æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    Priority: 1,            // ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
    Enabled: true,          // æ˜¯å¦å¯ç”¨
    ThreadId: 1,           // æ‰€å±çº¿ç¨‹
    AutoRefresh: true,      // æ˜¯å¦è‡ªåŠ¨ç»­æ—¶
    MinRemainingMs: 5000    // æœ€å°å‰©ä½™æ—¶é—´é˜ˆå€¼
}

; BuffçŠ¶æ€
BuffStatus := {
    LastCastTime: 0,        // ä¸Šæ¬¡æ–½æ³•æ—¶é—´
    NextRefreshTime: 0,     // ä¸‹æ¬¡ç»­æ—¶æ—¶é—´
    IsActive: false,        // æ˜¯å¦å¤„äºæ¿€æ´»çŠ¶æ€
    RemainingMs: 0          // å‰©ä½™æ—¶é—´
}
```

### æ ¸å¿ƒå‡½æ•°

#### ä¸»å¾ªç¯å¤„ç†

**BuffEngine_RunTick()**
```autohotkey
; Buffå¼•æ“ä¸»å¾ªç¯
BuffEngine_RunTick() {
    global App, BuffEngine
    
    if !BuffEngine.Configs.Length()
        return
    
    ; æŒ‰ä¼˜å…ˆçº§æ’åº
    sortedBuffs := BuffEngine_SortByPriority()
    
    ; æ£€æŸ¥æ¯ä¸ªBuff
    for buff in sortedBuffs {
        if !buff.Enabled
            continue
        
        BuffEngine_CheckBuffStatus(buff)
        
        ; æ£€æŸ¥æ˜¯å¦éœ€è¦ç»­æ—¶
        if BuffEngine_NeedRefresh(buff) {
            BuffEngine_RefreshBuff(buff)
        }
    }
}
```

#### BuffçŠ¶æ€æ£€æŸ¥

**BuffEngine_CheckBuffStatus()**
```autohotkey
; æ£€æŸ¥BuffçŠ¶æ€
BuffEngine_CheckBuffStatus(buff) {
    global Pixel
    
    ; å¦‚æœæ²¡æœ‰å¯¹åº”çš„æ£€æµ‹åƒç´ ï¼Œè·³è¿‡çŠ¶æ€æ£€æŸ¥
    if !buff.Has("CheckPixel")
        return
    
    ; æ£€æŸ¥Buffæ˜¯å¦ä»ç„¶å­˜åœ¨
    pixelColor := Pixel_GetPixelColor(buff.CheckPixel.X, buff.CheckPixel.Y)
    isActive := (pixelColor == buff.CheckPixel.ExpectedColor)
    
    buff.Status.IsActive := isActive
    
    if isActive {
        ; æ›´æ–°å‰©ä½™æ—¶é—´
        elapsed := A_TickCount - buff.Status.LastCastTime
        buff.Status.RemainingMs := buff.DurationMs - elapsed
        
        ; è®¡ç®—ä¸‹æ¬¡ç»­æ—¶æ—¶é—´
        refreshTime := buff.Status.RemainingMs - buff.MinRemainingMs
        buff.Status.NextRefreshTime := A_TickCount + refreshTime
    }
}
```

#### ç»­æ—¶åˆ¤æ–­

**BuffEngine_NeedRefresh()**
```autohotkey
; åˆ¤æ–­æ˜¯å¦éœ€è¦ç»­æ—¶
BuffEngine_NeedRefresh(buff) {
    if !buff.Status.IsActive
        return false
    
    if !buff.AutoRefresh
        return false
    
    ; æ£€æŸ¥æ—¶é—´é˜ˆå€¼
    currentTime := A_TickCount
    if (currentTime >= buff.Status.NextRefreshTime) {
        return true
    }
    
    return false
}
```

#### ç»­æ—¶æ‰§è¡Œ

**BuffEngine_RefreshBuff()**
```autohotkey
; æ‰§è¡ŒBuffç»­æ—¶
BuffEngine_RefreshBuff(buff) {
    ; æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å°±ç»ª
    if !Skill_IsReady(buff.SkillIndex) {
        BuffEngine_Log("æŠ€èƒ½æœªå°±ç»ªï¼Œè·³è¿‡ç»­æ—¶: " buff.Name)
        return false
    }
    
    ; å‘é€æŠ€èƒ½
    success := WorkerPool_SendSkillIndex(
        buff.ThreadId, 
        buff.SkillIndex, 
        "Buff:" buff.ID
    )
    
    if success {
        ; æ›´æ–°çŠ¶æ€
        buff.Status.LastCastTime := A_TickCount
        buff.Status.RemainingMs := buff.DurationMs
        
        BuffEngine_Log("Buffç»­æ—¶æˆåŠŸ: " buff.Name)
        return true
    }
    
    return false
}
```

### æŠ€èƒ½ä½¿ç”¨é€šçŸ¥

**BuffEngine_NotifySkillUsed()**
```autohotkey
; é€šçŸ¥æŠ€èƒ½ä½¿ç”¨
BuffEngine_NotifySkillUsed(skillIndex) {
    global BuffEngine
    
    ; æŸ¥æ‰¾ä½¿ç”¨è¯¥æŠ€èƒ½çš„Buff
    for buff in BuffEngine.Configs {
        if (buff.SkillIndex == skillIndex) {
            buff.Status.LastCastTime := A_TickCount
            buff.Status.RemainingMs := buff.DurationMs
            buff.Status.IsActive := true
            
            BuffEngine_Log("BuffçŠ¶æ€æ›´æ–°: " buff.Name)
            break
        }
    }
}
```

## 4. å±å¹•æ•è·å¼•æ“ - Dup.ahk

### æ ¸å¿ƒåŠŸèƒ½

Dupå¼•æ“è´Ÿè´£é«˜æ•ˆçš„å±å¹•å†…å®¹æ•è·ï¼Œæ”¯æŒå¤šç§æ•è·æŠ€æœ¯å’Œå¤šæ˜¾ç¤ºå™¨ç¯å¢ƒã€‚

**ä¸»è¦ç‰¹æ€§**:
- **DXGIå¤åˆ¶**: ä½¿ç”¨DXGI APIè¿›è¡Œé«˜æ€§èƒ½å±å¹•å¤åˆ¶
- **å¤šæ˜¾ç¤ºå™¨**: æ”¯æŒå¤šæ˜¾ç¤ºå™¨ç¯å¢ƒ
- **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯æ¢å¤æœºåˆ¶
- **è‡ªåŠ¨åˆå§‹åŒ–**: æ™ºèƒ½åˆå§‹åŒ–æµç¨‹
- **é™çº§æ–¹æ¡ˆ**: DXGIå¤±è´¥æ—¶è‡ªåŠ¨å›é€€åˆ°GDI

### æ•°æ®ç»“æ„

```autohotkey
; æ•è·å¼•æ“çŠ¶æ€
DupEngine := {
    Initialized: false,     // æ˜¯å¦å·²åˆå§‹åŒ–
    Method: "DXGI",         // æ•è·æ–¹æ³• (DXGI/GDI)
    OutputCount: 0,         // æ˜¾ç¤ºå™¨æ•°é‡
    SelectedOutput: 0,      // é€‰ä¸­çš„æ˜¾ç¤ºå™¨
    DXGIFactory: 0,         // DXGIå·¥å‚æ¥å£
    Device: 0,              // DXGIè®¾å¤‡
    Adapter: 0,             // DXGIé€‚é…å™¨
    LastError: "",          // æœ€åé”™è¯¯ä¿¡æ¯
    GDI: {                  // GDIç›¸å…³ä¿¡æ¯
        CompatibleDC: 0,
        CompatibleBitmap: 0,
        OldBitmap: 0
    }
}

; æ˜¾ç¤ºå™¨ä¿¡æ¯
OutputInfo := {
    Index: 0,              // æ˜¾ç¤ºå™¨ç´¢å¼•
    Name: "ä¸»æ˜¾ç¤ºå™¨",       // æ˜¾ç¤ºå™¨åç§°
    Width: 1920,           // å®½åº¦
    Height: 1080,          // é«˜åº¦
    Primary: true          // æ˜¯å¦ä¸ºä¸»æ˜¾ç¤ºå™¨
}
```

### æ ¸å¿ƒå‡½æ•°

#### åˆå§‹åŒ–

**Dup_Init()**
```autohotkey
; åˆå§‹åŒ–å±å¹•æ•è·å¼•æ“
Dup_Init() {
    global DupEngine
    
    ; å°è¯•DXGIåˆå§‹åŒ–
    if Dup_InitDXGI() {
        DupEngine.Method := "DXGI"
        DupEngine.Initialized := true
        Dup_Log("DXGIåˆå§‹åŒ–æˆåŠŸ")
        return true
    }
    
    ; DXGIå¤±è´¥ï¼Œå›é€€åˆ°GDI
    if Dup_InitGDI() {
        DupEngine.Method := "GDI"
        DupEngine.Initialized := true
        Dup_Log("GDIåˆå§‹åŒ–æˆåŠŸ")
        return true
    }
    
    Dup_Log("æ‰€æœ‰æ•è·æ–¹æ³•åˆå§‹åŒ–å¤±è´¥")
    return false
}
```

#### DXGIåˆå§‹åŒ–

**Dup_InitDXGI()**
```autohotkey
; DXGIåˆå§‹åŒ–
Dup_InitDXGI() {
    try {
        ; åˆ›å»ºDXGIå·¥å‚
        DupEngine.DXGIFactory := DllCall("DXGI.dll\CreateDXGIFactory", "Uint", "{7b7166ec-21c7-44ae-b21a-c9e07498542e}", "Ptr*")
        if (DupEngine.DXGIFactory == 0) {
            Dup_SetLastError("åˆ›å»ºDXGIå·¥å‚å¤±è´¥")
            return false
        }
        
        ; æšä¸¾é€‚é…å™¨
        adapter := 0
        i := 0
        while (DllCall(DupEngine.DXGIFactory "\EnumAdapters", "Uint", i, "Ptr*", &adapter) == 0) {
            ; è·å–è®¾å¤‡
            device := 0
            hr := DllCall("D3D11.dll\D3D11CreateDevice", "Ptr", adapter, "Uint", 1, "Uint", 0, "Ptr", 0, "Uint", 0x00010001, "Ptr*", &device, "Ptr", 0, "Ptr", 0)
            if (hr == 0) {
                DupEngine.Device := device
                DupEngine.Adapter := adapter
                break
            }
            i++
        }
        
        ; æšä¸¾è¾“å‡º
        output := 0
        j := 0
        while (DllCall(adapter "\EnumOutputs", "Uint", j, "Ptr*", &output) == 0) {
            ; è·å–è¾“å‡ºä¿¡æ¯
            desc := Buffer(64, 0)
            DllCall(output "\GetDesc", "Ptr", desc)
            ; å¤„ç†è¾“å‡ºä¿¡æ¯...
            j++
        }
        
        return true
    } catch {
        Dup_SetLastError("DXGIåˆå§‹åŒ–å¼‚å¸¸")
        return false
    }
}
```

#### GDIåˆå§‹åŒ–

**Dup_InitGDI()**
```autohotkey
; GDIåˆå§‹åŒ–
Dup_InitGDI() {
    try {
        ; è·å–æ¡Œé¢DC
        desktopDC := DllCall("GetDC", "Ptr", 0)
        if (desktopDC == 0) {
            Dup_SetLastError("è·å–æ¡Œé¢DCå¤±è´¥")
            return false
        }
        
        ; åˆ›å»ºå…¼å®¹DC
        compatibleDC := DllCall("CreateCompatibleDC", "Ptr", desktopDC)
        if (compatibleDC == 0) {
            DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
            Dup_SetLastError("åˆ›å»ºå…¼å®¹DCå¤±è´¥")
            return false
        }
        
        ; åˆ›å»ºå…¼å®¹ä½å›¾
        width := A_ScreenWidth
        height := A_ScreenHeight
        compatibleBitmap := DllCall("CreateCompatibleBitmap", "Ptr", desktopDC, "Int", width, "Int", height)
        if (compatibleBitmap == 0) {
            DllCall("DeleteDC", "Ptr", compatibleDC)
            DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
            Dup_SetLastError("åˆ›å»ºå…¼å®¹ä½å›¾å¤±è´¥")
            return false
        }
        
        ; é€‰æ‹©ä½å›¾åˆ°DC
        oldBitmap := DllCall("SelectObject", "Ptr", compatibleDC, "Ptr", compatibleBitmap)
        
        ; ä¿å­˜GDIç›¸å…³ä¿¡æ¯
        DupEngine.GDI.CompatibleDC := compatibleDC
        DupEngine.GDI.CompatibleBitmap := compatibleBitmap
        DupEngine.GDI.OldBitmap := oldBitmap
        
        return true
    } catch {
        Dup_SetLastError("GDIåˆå§‹åŒ–å¼‚å¸¸")
        return false
    }
}
```

#### å±å¹•æ•è·

**Dup_CaptureScreen()**
```autohotkey
; æ•è·å±å¹•
Dup_CaptureScreen(x := 0, y := 0, width := 0, height := 0) {
    global DupEngine
    
    if !DupEngine.Initialized {
        if !Dup_Init() {
            return 0
        }
    }
    
    if (DupEngine.Method == "DXGI") {
        return Dup_CaptureDXGI(x, y, width, height)
    } else {
        return Dup_CaptureGDI(x, y, width, height)
    }
}
```

**GDIæ•è·å®ç°**:
```autohotkey
Dup_CaptureGDI(x, y, width, height) {
    global DupEngine
    
    desktopDC := DllCall("GetDC", "Ptr", 0)
    compatibleDC := DupEngine.GDI.CompatibleDC
    compatibleBitmap := DupEngine.GDI.CompatibleBitmap
    
    ; è®¾ç½®æ•è·åŒºåŸŸ
    if (width == 0) width := A_ScreenWidth
    if (height == 0) height := A_ScreenHeight
    
    ; æ‰§è¡Œä½å—ä¼ è¾“
    result := DllCall("BitBlt", "Ptr", compatibleDC, "Int", 0, "Int", 0, "Int", width, "Int", height, "Ptr", desktopDC, "Int", x, "Int", y, "Uint", 0x00CC0020)
    
    DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
    
    if (result) {
        return compatibleBitmap
    } else {
        Dup_SetLastError("BitBltæ•è·å¤±è´¥")
        return 0
    }
}
```

## 5. åƒç´ æ£€æµ‹å¼•æ“ - Pixel.ahk

### æ ¸å¿ƒåŠŸèƒ½

Pixelå¼•æ“æä¾›é«˜ç²¾åº¦çš„åƒç´ æ£€æµ‹å’Œåˆ†æåŠŸèƒ½ï¼Œæ˜¯æ•´ä¸ªè‡ªåŠ¨åŒ–ç³»ç»Ÿçš„çœ¼ç›ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **é¢œè‰²è½¬æ¢**: RGBä¸åå…­è¿›åˆ¶é¢œè‰²æ ¼å¼è½¬æ¢
- **é¢œè‰²åŒ¹é…**: å®¹å·®èŒƒå›´å†…çš„é¢œè‰²åŒ¹é…
- **å¤šå±‚ç¼“å­˜**: DXGIâ†’ROIâ†’GDIä¸‰çº§ç¼“å­˜ç³»ç»Ÿ
- **ROIå¿«ç…§**: åŒºåŸŸå…´è¶£å¿«ç…§åŠŸèƒ½
- **æ€§èƒ½ä¼˜åŒ–**: æ™ºèƒ½ç¼“å­˜å’Œæ‰¹é‡æ£€æµ‹

### æ•°æ®ç»“æ„

```autohotkey
; åƒç´ å¼•æ“çŠ¶æ€
PixelEngine := {
    Cache: {                // ç¼“å­˜ç³»ç»Ÿ
        DXGI: Map(),        // DXGIå¸§ç¼“å­˜
        ROI: Map(),         // ROIåŒºåŸŸç¼“å­˜
        GDI: Map(),         // GDIä½å›¾ç¼“å­˜
        FrameId: 0,         // å¸§ID
        LastUpdate: 0       // æœ€åæ›´æ–°æ—¶é—´
    },
    CurrentROI: {           // å½“å‰ROIåŒºåŸŸ
        X: 0,
        Y: 0,
        Width: 100,
        Height: 50,
        Enabled: false
    },
    ColorFormat: "RGB"      // é¢œè‰²æ ¼å¼
}
```

### æ ¸å¿ƒå‡½æ•°

#### é¢œè‰²å¤„ç†

**Pixel_ConvertColor()**
```autohotkey
; é¢œè‰²æ ¼å¼è½¬æ¢
Pixel_ConvertColor(color, fromFormat, toFormat) {
    switch fromFormat {
        case "RGB":
            return Pixel_RGBToHex(color)
        case "HEX":
            return Pixel_HexToRGB(color)
    }
    return color
}

Pixel_RGBToHex(rgb) {
    r := (rgb >> 16) & 0xFF
    g := (rgb >> 8) & 0xFF
    b := rgb & 0xFF
    return Format("0x{1:02X}{2:02X}{3:02X}", r, g, b)
}
```

#### ç¼“å­˜ç³»ç»Ÿ

**Pixel_GetPixelFromCache()**
```autohotkey
; ä»ç¼“å­˜è·å–åƒç´ 
Pixel_GetPixelFromCache(x, y) {
    global PixelEngine, DupEngine
    
    ; ä¼˜å…ˆçº§æ£€æŸ¥ï¼šDXGI â†’ ROI â†’ GDI
    
    ; 1. DXGIç¼“å­˜
    if DupEngine.Method == "DXGI" {
        cached := Pixel_GetDXGIFrame()
        if (cached != 0) {
            color := Pixel_ReadPixelFromDXGI(cached, x, y)
            if (color != 0) {
                return color
            }
        }
    }
    
    ; 2. ROIç¼“å­˜
    if PixelEngine.CurrentROI.Enabled && Pixel_IsInROI(x, y) {
        cached := Pixel_GetROICache()
        if (cached != 0) {
            relX := x - PixelEngine.CurrentROI.X
            relY := y - PixelEngine.CurrentROI.Y
            color := Pixel_ReadPixelFromROI(cached, relX, relY)
            if (color != 0) {
                return color
            }
        }
    }
    
    ; 3. GDIç¼“å­˜
    cached := Pixel_GetGDICache()
    if (cached != 0) {
        color := Pixel_ReadPixelFromGDI(cached, x, y)
        if (color != 0) {
            return color
        }
    }
    
    ; 4. å®æ—¶æ•è·
    return Pixel_CaptureAndRead(x, y)
}
```

#### ROIå¿«ç…§

**Pixel_CaptureROI()**
```autohotkey
; æ•è·ROIåŒºåŸŸ
Pixel_CaptureROI() {
    global PixelEngine, DupEngine
    
    if !PixelEngine.CurrentROI.Enabled
        return 0
    
    roi := PixelEngine.CurrentROI
    
    ; æ•è·æŒ‡å®šåŒºåŸŸ
    bitmap := Dup_CaptureScreen(roi.X, roi.Y, roi.Width, roi.Height)
    if (bitmap != 0) {
        ; ç¼“å­˜ROIæ•°æ®
        PixelEngine.Cache.ROI.Set("Bitmap", bitmap)
        PixelEngine.Cache.ROI.Set("Width", roi.Width)
        PixelEngine.Cache.ROI.Set("Height", roi.Height)
        PixelEngine.Cache.ROI.Set("Timestamp", A_TickCount)
    }
    
    return bitmap
}
```

#### é¢œè‰²åŒ¹é…

**Pixel_MatchColor()**
```autohotkey
; é¢œè‰²åŒ¹é…æ£€æµ‹
Pixel_MatchColor(x, y, expectedColor, tolerance := 0) {
    actualColor := Pixel_GetPixel(x, y)
    
    if (tolerance == 0) {
        return (actualColor == expectedColor)
    }
    
    ; è®¡ç®—é¢œè‰²å·®å¼‚
    diff := Pixel_CalculateColorDiff(actualColor, expectedColor)
    return (diff <= tolerance)
}

Pixel_CalculateColorDiff(color1, color2) {
    ; åˆ†åˆ«è®¡ç®—RGBåˆ†é‡çš„å·®å¼‚
    r1 := (color1 >> 16) & 0xFF
    g1 := (color1 >> 8) & 0xFF
    b1 := color1 & 0xFF
    
    r2 := (color2 >> 16) & 0xFF
    g2 := (color2 >> 8) & 0xFF
    b2 := color2 & 0xFF
    
    ; è®¡ç®—æ¬§æ°è·ç¦»
    diff := Sqrt((r1 - r2)**2 + (g1 - g2)**2 + (b1 - b2)**2)
    return diff
}
```

## 6. è½®è¯¢è°ƒåº¦å¼•æ“ - Poller.ahk

### æ ¸å¿ƒåŠŸèƒ½

Pollerå¼•æ“æ˜¯æ•´ä¸ªç³»ç»Ÿçš„è°ƒåº¦ä¸­å¿ƒï¼Œè´Ÿè´£åè°ƒæ‰€æœ‰å…¶ä»–å¼•æ“çš„å·¥ä½œï¼Œå®ç°é«˜æ•ˆçš„è½®è¯¢è°ƒåº¦ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **ä¼˜å…ˆçº§è°ƒåº¦**: æŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œå„å¼•æ“
- **çŠ¶æ€ç®¡ç†**: å®æ—¶ç›‘æ§ç³»ç»Ÿè¿è¡ŒçŠ¶æ€
- **æ•…éšœæ¢å¤**: è‡ªåŠ¨æ£€æµ‹å’Œæ¢å¤æ•…éšœç»„ä»¶
- **æ€§èƒ½ç›‘æ§**: ç›‘æ§å„å¼•æ“çš„æ‰§è¡Œæ€§èƒ½
- **èµ„æºç®¡ç†**: åˆç†çš„èµ„æºåˆ†é…å’Œé‡Šæ”¾

### æ•°æ®ç»“æ„

```autohotkey
; è½®è¯¢å¼•æ“çŠ¶æ€
Poller := {
    Running: false,         // è¿è¡ŒçŠ¶æ€
    Interval: 10,           // è½®è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    LastTickTime: 0,        // ä¸Šæ¬¡è½®è¯¢æ—¶é—´
    ThreadCount: 1,         // å·¥ä½œçº¿ç¨‹æ•°
    EngineStatus: {         // å¼•æ“çŠ¶æ€
        BuffEngine: true,
        RotationEngine: true,
        RuleEngine: true,
        PixelEngine: true
    },
    Performance: {          // æ€§èƒ½ç»Ÿè®¡
        TotalTicks: 0,
        AvgTickTime: 0,
        LastTickTime: 0
    }
}
```

### æ ¸å¿ƒå‡½æ•°

#### ä¸»å¾ªç¯

**Poller_Tick()**
```autohotkey
; è½®è¯¢ä¸»å¾ªç¯
Poller_Tick() {
    global Poller
    
    if !Poller.Running
        return
    
    startTime := A_TickCount
    
    try {
        ; æŒ‰ä¼˜å…ˆçº§é¡ºåºæ‰§è¡Œ
        
        ; 1. Buffå¼•æ“ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
        if Poller.EngineStatus.BuffEngine {
            Poller_RunBuffEngine()
        }
        
        ; 2. è½®æ¢å¼•æ“æˆ–è§„åˆ™å¼•æ“
        if Poller.EngineStatus.RotationEngine || Poller.EngineStatus.RuleEngine {
            Poller_RunSkillEngine()
        }
        
        ; 3. é»˜è®¤æŠ€èƒ½å…œåº•
        Poller_RunDefaultSkills()
        
        ; 4. çŠ¶æ€é‡ç½®
        Poller_ResetStates()
        
        ; æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        Poller_UpdatePerformance(A_TickCount - startTime)
        
    } catch error {
        Poller_HandleError("è½®è¯¢å¼‚å¸¸: " . error.message)
    }
}
```

#### å¼•æ“è°ƒåº¦

**Poller_RunBuffEngine()**
```autohotkey
; è¿è¡ŒBuffå¼•æ“
Poller_RunBuffEngine() {
    try {
        BuffEngine_RunTick()
    } catch error {
        Poller_SetEngineError("BuffEngine", error.message)
    }
}

Poller_RunSkillEngine() {
    ; ä¼˜å…ˆä½¿ç”¨è½®æ¢å¼•æ“ï¼Œå¦åˆ™ä½¿ç”¨è§„åˆ™å¼•æ“
    if Poller.EngineStatus.RotationEngine {
        try {
            Rotation_RunTick()
        } catch error {
            Poller_SetEngineError("RotationEngine", error.message)
            ; è½®æ¢å¼•æ“å¤±è´¥æ—¶ï¼Œå›é€€åˆ°è§„åˆ™å¼•æ“
            try {
                RuleEngine_RunTick()
            } catch {
                Poller_SetEngineError("RuleEngine", "è§„åˆ™å¼•æ“ä¹Ÿå¤±è´¥")
            }
        }
    } else if Poller.EngineStatus.RuleEngine {
        try {
            RuleEngine_RunTick()
        } catch error {
            Poller_SetEngineError("RuleEngine", error.message)
        }
    }
}

Poller_RunDefaultSkills() {
    global App
    
    ; æ‰§è¡Œé»˜è®¤æŠ€èƒ½åºåˆ—
    if App.Has("ProfileData") && App["ProfileData"].Has("DefaultSkills") {
        defaultSkills := App["ProfileData"]["DefaultSkills"]
        
        for skill in defaultSkills {
            if Skill_IsReady(skill.Index) && Skill_ShouldUseDefault(skill) {
                WorkerPool_SendSkillIndex(1, skill.Index, "Default")
                break  ; åªæ‰§è¡Œä¸€ä¸ªé»˜è®¤æŠ€èƒ½
            }
        }
    }
}
```

#### çŠ¶æ€ç®¡ç†

**Poller_ResetStates()**
```autohotkey
; é‡ç½®å„å¼•æ“çŠ¶æ€
Poller_ResetStates() {
    ; é‡ç½®æ—‹è½¬å¼•æ“çŠ¶æ€
    if Poller.EngineStatus.RotationEngine {
        Rotation_ResetTickState()
    }
    
    ; é‡ç½®åƒç´ ç¼“å­˜
    Pixel_ResetFrameCache()
    
    ; æ¸…ç†ä¸´æ—¶æ•°æ®
    Poller_CleanupTempData()
}
```

#### æ€§èƒ½ç›‘æ§

**Poller_UpdatePerformance()**
```autohotkey
; æ›´æ–°æ€§èƒ½ç»Ÿè®¡
Poller_UpdatePerformance(tickTime) {
    global Poller
    
    Poller.Performance.TotalTicks++
    Poller.Performance.LastTickTime := tickTime
    
    ; è®¡ç®—å¹³å‡æ‰§è¡Œæ—¶é—´
    totalTime := Poller.Performance.AvgTickTime * (Poller.Performance.TotalTicks - 1)
    Poller.Performance.AvgTickTime := (totalTime + tickTime) / Poller.Performance.TotalTicks
    
    ; æ£€æŸ¥æ€§èƒ½è­¦å‘Š
    if (tickTime > Poller.Interval * 0.8) {
        Poller_Log("æ€§èƒ½è­¦å‘Š: è½®è¯¢è€—æ—¶ " tickTime "ms è¶…è¿‡é˜ˆå€¼")
    }
}
```

## å¼•æ“é—´åä½œæœºåˆ¶

### äº‹ä»¶ç³»ç»Ÿ

**äº‹ä»¶ä¼ é€’**:
```autohotkey
; æŠ€èƒ½ä½¿ç”¨äº‹ä»¶
Skill_NotifyUsage(skillIndex, threadId) {
    ; é€šçŸ¥Buffå¼•æ“
    BuffEngine_NotifySkillUsed(skillIndex)
    
    ; æ›´æ–°è®¡æ•°å™¨
    Counters_Inc(skillIndex)
    
    ; é€šçŸ¥æ—‹è½¬å¼•æ“
    Rotation_OnSkillUsed(skillIndex)
    
    ; è®°å½•æ—¥å¿—
    Poller_Log("æŠ€èƒ½ä½¿ç”¨: " skillIndex " çº¿ç¨‹: " threadId)
}
```

### æ•°æ®å…±äº«

**å…¨å±€çŠ¶æ€ç®¡ç†**:
```autohotkey
; å…±äº«æŠ€èƒ½æ•°æ®
global App := {
    ProfileData: {
        Skills: [],         // æŠ€èƒ½åˆ—è¡¨
        Rotation: {},       // è½®æ¢é…ç½®
        Buffs: [],          // Buffé…ç½®
        Rules: []           // è§„åˆ™é…ç½®
    }
}
```

### é”™è¯¯æ¢å¤

**å¼•æ“æ•…éšœæ¢å¤**:
```autohotkey
Poller_HandleEngineFailure(engineName, error) {
    global Poller
    
    ; æ ‡è®°å¼•æ“ä¸ºæ•…éšœçŠ¶æ€
    Poller.EngineStatus.%engineName% := false
    
    ; è®°å½•é”™è¯¯
    Poller_Log("å¼•æ“æ•…éšœ: " engineName " - " error)
    
    ; å°è¯•é‡å¯æ•…éšœå¼•æ“
    switch engineName {
        case "BuffEngine":
            Poller_RestartBuffEngine()
        case "RotationEngine":
            Poller_RestartRotationEngine()
        case "RuleEngine":
            Poller_RestartRuleEngine()
    }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ç¼“å­˜ç­–ç•¥

1. **DXGIç¼“å­˜**: ä¿å­˜æ•´å¸§å±å¹•æ•°æ®
2. **ROIç¼“å­˜**: ä¿å­˜æ„Ÿå…´è¶£åŒºåŸŸæ•°æ®  
3. **GDIç¼“å­˜**: å¤‡ç”¨æ•è·æ•°æ®
4. **é¢œè‰²ç¼“å­˜**: ç¼“å­˜å¸¸ç”¨é¢œè‰²å€¼

### å¹¶å‘æ§åˆ¶

1. **ä¼˜å…ˆçº§è°ƒåº¦**: é«˜ä¼˜å…ˆçº§ä»»åŠ¡ä¼˜å…ˆæ‰§è¡Œ
2. **æ—¶é—´ç‰‡åˆ†é…**: åˆç†åˆ†é…å„å¼•æ“æ‰§è¡Œæ—¶é—´
3. **èµ„æºé”å®š**: é¿å…èµ„æºç«äº‰
4. **å¼‚æ­¥å¤„ç†**: è€—æ—¶æ“ä½œå¼‚æ­¥æ‰§è¡Œ

### å†…å­˜ç®¡ç†

1. **å¯¹è±¡æ± **: é‡ç”¨ä¸´æ—¶å¯¹è±¡
2. **åŠæ—¶é‡Šæ”¾**: åŠæ—¶é‡Šæ”¾ä¸éœ€è¦çš„èµ„æº
3. **å†…å­˜ç›‘æ§**: ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ
4. **åƒåœ¾å›æ”¶**: ä¸»åŠ¨è§¦å‘åƒåœ¾å›æ”¶

## æ€»ç»“

å¼•æ“æ¨¡å—æ˜¯Game Macroçš„æ ¸å¿ƒç»„ä»¶ï¼Œé€šè¿‡å…­å¤§å¼•æ“çš„ååŒå·¥ä½œï¼Œå®ç°äº†å®Œæ•´çš„æ¸¸æˆè‡ªåŠ¨åŒ–åŠŸèƒ½ã€‚æ¯ä¸ªå¼•æ“éƒ½æœ‰æ˜ç¡®çš„èŒè´£è¾¹ç•Œå’Œé«˜æ•ˆçš„æ‰§è¡Œæœºåˆ¶ï¼Œé€šè¿‡äº‹ä»¶é©±åŠ¨å’Œæ•°æ®å…±äº«å®ç°æ¨¡å—é—´çš„æ— ç¼åä½œã€‚

**æ ¸å¿ƒä¼˜åŠ¿**:
- âœ… æ¨¡å—åŒ–è®¾è®¡ï¼ŒåŠŸèƒ½èŒè´£æ¸…æ™°
- âœ… å¤šå±‚ç¼“å­˜æœºåˆ¶ï¼Œæ€§èƒ½è¡¨ç°ä¼˜å¼‚
- âœ… å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
- âœ… çµæ´»çš„æ‰©å±•æ€§å’Œé…ç½®èƒ½åŠ›
- âœ… é«˜ç²¾åº¦çš„æ£€æµ‹å’Œæ‰§è¡Œèƒ½åŠ›

**åº”ç”¨ä»·å€¼**:
- ä¸ºå¤æ‚æ¸¸æˆè‡ªåŠ¨åŒ–æä¾›å¯é çš„æŠ€æœ¯åŸºç¡€
- é€šè¿‡æ¨¡å—åŒ–å®ç°åŠŸèƒ½çš„çµæ´»ç»„åˆ
- ä¸ºæ¸¸æˆç©å®¶æä¾›æ™ºèƒ½åŒ–çš„æ“ä½œä½“éªŒ
- ä¸ºå¼€å‘è€…æä¾›å¯æ‰©å±•çš„è‡ªåŠ¨åŒ–æ¡†æ¶

---

*ğŸ“ æœ€åæ›´æ–°: 2025-11-29*  
*ğŸ”„ æ–‡æ¡£ç‰ˆæœ¬: v1.1*  
*ğŸ‘¨â€ğŸ’» ç»´æŠ¤å›¢é˜Ÿ: Game Macroå¼€å‘ç»„*