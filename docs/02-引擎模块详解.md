# 引擎模块详解 - Engine Modules Documentation

## 概述

游戏宏工具的引擎模块是整个系统的核心处理单元，负责实现各种自动化功能。引擎模块采用模块化设计，每个引擎负责特定的功能领域，通过协调配合实现复杂的游戏自动化操作。

## 引擎架构概览

### 核心引擎列表

1. **Rotation.ahk** - 技能轮换引擎
2. **RuleEngine.ahk** - 规则引擎
3. **BuffEngine.ahk** - Buff续时引擎  
4. **Dup.ahk** - 屏幕捕获引擎
5. **Pixel.ahk** - 像素检测引擎
6. **Poller.ahk** - 轮询调度引擎

### 引擎协作关系

```
Poller (轮询调度)
    ├── Dup (屏幕捕获)
    ├── Pixel (像素检测)
    ├── BuffEngine (Buff续时)
    └── Rotation/RuleEngine (技能释放)
         └── WorkerPool (按键发送)
```

## 1. 技能轮换引擎 - Rotation.ahk

### 核心功能

技能轮换引擎是游戏自动化中最复杂的组件之一，负责管理复杂的技能释放序列。

**主要特性**:
- **多轨道轮换**: 支持定义多个技能轨道（Tracks）
- **Gate条件系统**: 基于条件的智能跳轨功能
- **起手技能**: 专门的起手技能处理
- **防抖机制**: 防止技能频繁触发
- **BusyWindow**: 检测和避免窗口忙碌状态

### 核心数据结构

```autohotkey
; 轮换配置结构
Rotation := {
    Tracks: [],           // 轨道数组
    CurrentTrack: 1,      // 当前轨道索引
    GateConditions: [],   // Gate条件列表
    BlackBox: {           // 黑框配置
        X: 0,
        Y: 0, 
        Width: 100,
        Height: 50,
        Enabled: true
    },
    BusyWindow: {         // 忙碌窗口配置
        MinDelay: 100,
        MaxDelay: 500
    }
}

; 技能数据结构
SkillData := {
    Index: 1,             // 技能索引
    Name: "技能名称",      // 技能名称
    Key: "Q",             // 按键
    Enabled: true,        // 是否启用
    Track: 1,            // 所属轨道
    CastMs: 500,         // 施法时间
    HoldMs: 100,         // 按键持续时间
    CooldownMs: 1000     // 冷却时间
}
```

### 核心函数

#### 初始化函数

**Rotation_InitFromProfile()**
```autohotkey
; 从配置文件初始化轮换引擎
Rotation_InitFromProfile() {
    global App, Rotation
    
    ; 读取配置文件中的轮换设置
    if App.Has("ProfileData") && App["ProfileData"].Has("Rotation") {
        rot := App["ProfileData"]["Rotation"]
        
        ; 初始化轨道
        if rot.Has("Tracks") {
            Rotation.Tracks := rot["Tracks"]
        }
        
        ; 初始化Gate条件
        if rot.Has("GateConditions") {
            Rotation.GateConditions := rot["GateConditions"]
        }
        
        ; 初始化黑框检测
        if rot.Has("BlackBox") {
            Rotation.BlackBox := rot["BlackBox"]
        }
    }
    
    ; 设置默认轨道
    Rotation.CurrentTrack := 1
}
```

#### 轮换控制函数

**Rotation_Reset()**
```autohotkey
; 重置轮换状态
Rotation_Reset() {
    global Rotation
    Rotation.CurrentTrack := 1
    ; 重置相关状态
    ; ...
}
```

**Rotation_GetNextSkill()**
```autohotkey
; 获取下一个技能
Rotation_GetNextSkill() {
    global App, Rotation
    
    if !Rotation.Tracks.Length()
        return 0
    
    track := Rotation.Tracks[Rotation.CurrentTrack]
    
    ; 检查Gate条件
    if Rotation_CheckGateConditions(track) {
        Rotation_SwitchToNextTrack()
        track := Rotation.Tracks[Rotation.CurrentTrack]
    }
    
    ; 从当前轨道获取技能
    return Rotation_GetSkillFromTrack(track)
}
```

#### Gate条件系统

**Rotation_CheckGateConditions()**
```autohotkey
; 检查是否满足跳轨条件
Rotation_CheckGateConditions(track) {
    global Rotation, Pixel
    
    if !Rotation.GateConditions.Length()
        return false
    
    for condition in Rotation.GateConditions {
        ; 检查条件类型
        switch condition.Type {
            case "PixelColor":
                color := Pixel_GetPixelColor(condition.X, condition.Y)
                if (color == condition.ExpectedColor) {
                    return true
                }
            case "SkillCooldown":
                ; 检查技能冷却状态
                if (Skill_IsReady(condition.SkillIndex)) {
                    return true
                }
        }
    }
    return false
}
```

### 轨道管理

**轨道切换逻辑**:
```autohotkey
Rotation_SwitchToNextTrack() {
    global Rotation
    
    Rotation.CurrentTrack++
    if (Rotation.CurrentTrack > Rotation.Tracks.Length()) {
        Rotation.CurrentTrack := 1
    }
    
    ; 记录切换日志
    Rotation_Log("Switched to track: " Rotation.CurrentTrack)
}
```

### 防抖机制

**黑框检测**:
```autohotkey
Rotation_CheckBlackBox() {
    global Rotation, Pixel
    
    if !Rotation.BlackBox.Enabled
        return true
    
    ; 检测黑框区域
    color := Pixel_GetAverageColor(
        Rotation.BlackBox.X,
        Rotation.BlackBox.Y,
        Rotation.BlackBox.Width,
        Rotation.BlackBox.Height
    )
    
    ; 如果是黑色（或其他指定颜色），认为处于防抖状态
    return (color != 0x000000)
}
```

## 2. 规则引擎 - RuleEngine.ahk

### 核心功能

规则引擎提供灵活的基于条件的技能释放系统，支持复杂的条件判断和动作执行。

**主要特性**:
- **条件判断**: 支持像素颜色、技能冷却等多种条件
- **规则过滤**: 灵活的规则启用/禁用控制
- **计数模式**: 基于技能使用次数的规则触发
- **调试日志**: 详细的执行日志和屏幕提示
- **回执校验**: 技能发送成功验证

### 数据结构

```autohotkey
; 规则结构
Rule := {
    ID: "rule_001",           // 规则唯一标识
    Name: "回血技能规则",       // 规则名称
    Enabled: true,            // 是否启用
    ThreadId: 1,             // 所属线程
    Conditions: [],          // 条件列表
    Actions: [],             // 动作列表
    CountMode: false,        // 是否启用计数模式
    TriggerCount: 5,         // 触发计数
    CooldownMs: 1000,        // 冷却时间
    LastTriggerTime: 0       // 上次触发时间
}

; 条件结构
Condition := {
    Type: "PixelColor",      // 条件类型
    X: 100,                  // X坐标
    Y: 200,                  // Y坐标
    ExpectedColor: "0xFF0000", // 期望颜色
    Tolerance: 10,           // 颜色容差
    Description: "血量检测点"  // 条件描述
}

; 动作结构
Action := {
    Type: "UseSkill",        // 动作类型
    SkillIndex: 1,           // 技能索引
    Key: "Q",               // 按键
    HoldMs: 100,            // 按键持续时间
    Description: "释放回血技能" // 动作描述
}
```

### 核心函数

#### 规则执行

**RuleEngine_RunTick()**
```autohotkey
; 规则引擎主循环
RuleEngine_RunTick() {
    global App, RuleEngine
    
    if !RuleEngine.Rules.Length()
        return
    
    ; 遍历所有规则
    for rule in RuleEngine.Rules {
        if !rule.Enabled
            continue
        
        ; 检查冷却时间
        if RuleEngine_CheckCooldown(rule)
            continue
        
        ; 检查条件
        if RuleEngine_CheckConditions(rule) {
            ; 执行动作
            RuleEngine_ExecuteActions(rule)
            
            ; 更新触发时间
            rule.LastTriggerTime := A_TickCount
            
            ; 记录日志
            RuleEngine_Log(rule.Name " 规则触发")
        }
    }
}
```

#### 条件检查

**RuleEngine_CheckConditions()**
```autohotkey
; 检查规则条件
RuleEngine_CheckConditions(rule) {
    for condition in rule.Conditions {
        if !RuleEngine_CheckSingleCondition(condition) {
            return false
        }
    }
    return true
}

RuleEngine_CheckSingleCondition(condition) {
    switch condition.Type {
        case "PixelColor":
            return RuleEngine_CheckPixelColor(condition)
        case "SkillCooldown":
            return RuleEngine_CheckSkillCooldown(condition)
        case "HPPercent":
            return RuleEngine_CheckHPPercent(condition)
        case "MPPercent":
            return RuleEngine_CheckMPPercent(condition)
    }
    return false
}
```

**像素颜色检查**:
```autohotkey
RuleEngine_CheckPixelColor(condition) {
    global Pixel
    
    actualColor := Pixel_GetPixelColor(condition.X, condition.Y)
    expectedColor := condition.ExpectedColor
    
    ; 计算颜色差异
    diff := Pixel_CalculateColorDiff(actualColor, expectedColor)
    
    return (diff <= condition.Tolerance)
}
```

#### 动作执行

**RuleEngine_ExecuteActions()**
```autohotkey
; 执行规则动作
RuleEngine_ExecuteActions(rule) {
    for action in rule.Actions {
        switch action.Type {
            case "UseSkill":
                WorkerPool_SendSkillIndex(rule.ThreadId, action.SkillIndex, "Rule:" rule.ID)
            case "SendKey":
                WorkerPool_FireAndForget(action.Key)
        }
    }
}
```

### 计数模式

**计数功能**:
```autohotkey
RuleEngine_CheckCountMode(rule) {
    if !rule.CountMode
        return true
    
    ; 检查各技能的触发次数
    for condition in rule.Conditions {
        if condition.Type == "UseSkill" {
            count := Counters_Get(condition.SkillIndex)
            if (count >= rule.TriggerCount) {
                return true
            }
        }
    }
    return false
}
```

## 3. Buff续时引擎 - BuffEngine.ahk

### 核心功能

BuffEngine专门负责管理游戏的Buff续时功能，确保重要增益效果不会中断。

**主要特性**:
- **优先续时**: 智能的Buff优先级管理
- **多线程**: 支持多线程并发处理
- **技能检测**: 自动检测技能就绪状态
- **计时精确**: 精确的Buff持续时间管理
- **续时预测**: 提前预测Buff到期时间

### 数据结构

```autohotkey
; Buff配置
BuffConfig := {
    ID: "buff_001",          // Buff标识
    Name: "力量增强",         // Buff名称
    SkillIndex: 1,          // 对应技能索引
    DurationMs: 30000,      // 持续时间（毫秒）
    Priority: 1,            // 优先级（数字越小优先级越高）
    Enabled: true,          // 是否启用
    ThreadId: 1,           // 所属线程
    AutoRefresh: true,      // 是否自动续时
    MinRemainingMs: 5000    // 最小剩余时间阈值
}

; Buff状态
BuffStatus := {
    LastCastTime: 0,        // 上次施法时间
    NextRefreshTime: 0,     // 下次续时时间
    IsActive: false,        // 是否处于激活状态
    RemainingMs: 0          // 剩余时间
}
```

### 核心函数

#### 主循环处理

**BuffEngine_RunTick()**
```autohotkey
; Buff引擎主循环
BuffEngine_RunTick() {
    global App, BuffEngine
    
    if !BuffEngine.Configs.Length()
        return
    
    ; 按优先级排序
    sortedBuffs := BuffEngine_SortByPriority()
    
    ; 检查每个Buff
    for buff in sortedBuffs {
        if !buff.Enabled
            continue
        
        BuffEngine_CheckBuffStatus(buff)
        
        ; 检查是否需要续时
        if BuffEngine_NeedRefresh(buff) {
            BuffEngine_RefreshBuff(buff)
        }
    }
}
```

#### Buff状态检查

**BuffEngine_CheckBuffStatus()**
```autohotkey
; 检查Buff状态
BuffEngine_CheckBuffStatus(buff) {
    global Pixel
    
    ; 如果没有对应的检测像素，跳过状态检查
    if !buff.Has("CheckPixel")
        return
    
    ; 检查Buff是否仍然存在
    pixelColor := Pixel_GetPixelColor(buff.CheckPixel.X, buff.CheckPixel.Y)
    isActive := (pixelColor == buff.CheckPixel.ExpectedColor)
    
    buff.Status.IsActive := isActive
    
    if isActive {
        ; 更新剩余时间
        elapsed := A_TickCount - buff.Status.LastCastTime
        buff.Status.RemainingMs := buff.DurationMs - elapsed
        
        ; 计算下次续时时间
        refreshTime := buff.Status.RemainingMs - buff.MinRemainingMs
        buff.Status.NextRefreshTime := A_TickCount + refreshTime
    }
}
```

#### 续时判断

**BuffEngine_NeedRefresh()**
```autohotkey
; 判断是否需要续时
BuffEngine_NeedRefresh(buff) {
    if !buff.Status.IsActive
        return false
    
    if !buff.AutoRefresh
        return false
    
    ; 检查时间阈值
    currentTime := A_TickCount
    if (currentTime >= buff.Status.NextRefreshTime) {
        return true
    }
    
    return false
}
```

#### 续时执行

**BuffEngine_RefreshBuff()**
```autohotkey
; 执行Buff续时
BuffEngine_RefreshBuff(buff) {
    ; 检查技能是否就绪
    if !Skill_IsReady(buff.SkillIndex) {
        BuffEngine_Log("技能未就绪，跳过续时: " buff.Name)
        return false
    }
    
    ; 发送技能
    success := WorkerPool_SendSkillIndex(
        buff.ThreadId, 
        buff.SkillIndex, 
        "Buff:" buff.ID
    )
    
    if success {
        ; 更新状态
        buff.Status.LastCastTime := A_TickCount
        buff.Status.RemainingMs := buff.DurationMs
        
        BuffEngine_Log("Buff续时成功: " buff.Name)
        return true
    }
    
    return false
}
```

### 技能使用通知

**BuffEngine_NotifySkillUsed()**
```autohotkey
; 通知技能使用
BuffEngine_NotifySkillUsed(skillIndex) {
    global BuffEngine
    
    ; 查找使用该技能的Buff
    for buff in BuffEngine.Configs {
        if (buff.SkillIndex == skillIndex) {
            buff.Status.LastCastTime := A_TickCount
            buff.Status.RemainingMs := buff.DurationMs
            buff.Status.IsActive := true
            
            BuffEngine_Log("Buff状态更新: " buff.Name)
            break
        }
    }
}
```

## 4. 屏幕捕获引擎 - Dup.ahk

### 核心功能

Dup引擎负责高效的屏幕内容捕获，支持多种捕获技术和多显示器环境。

**主要特性**:
- **DXGI复制**: 使用DXGI API进行高性能屏幕复制
- **多显示器**: 支持多显示器环境
- **错误处理**: 完善的错误恢复机制
- **自动初始化**: 智能初始化流程
- **降级方案**: DXGI失败时自动回退到GDI

### 数据结构

```autohotkey
; 捕获引擎状态
DupEngine := {
    Initialized: false,     // 是否已初始化
    Method: "DXGI",         // 捕获方法 (DXGI/GDI)
    OutputCount: 0,         // 显示器数量
    SelectedOutput: 0,      // 选中的显示器
    DXGIFactory: 0,         // DXGI工厂接口
    Device: 0,              // DXGI设备
    Adapter: 0,             // DXGI适配器
    LastError: "",          // 最后错误信息
    GDI: {                  // GDI相关信息
        CompatibleDC: 0,
        CompatibleBitmap: 0,
        OldBitmap: 0
    }
}

; 显示器信息
OutputInfo := {
    Index: 0,              // 显示器索引
    Name: "主显示器",       // 显示器名称
    Width: 1920,           // 宽度
    Height: 1080,          // 高度
    Primary: true          // 是否为主显示器
}
```

### 核心函数

#### 初始化

**Dup_Init()**
```autohotkey
; 初始化屏幕捕获引擎
Dup_Init() {
    global DupEngine
    
    ; 尝试DXGI初始化
    if Dup_InitDXGI() {
        DupEngine.Method := "DXGI"
        DupEngine.Initialized := true
        Dup_Log("DXGI初始化成功")
        return true
    }
    
    ; DXGI失败，回退到GDI
    if Dup_InitGDI() {
        DupEngine.Method := "GDI"
        DupEngine.Initialized := true
        Dup_Log("GDI初始化成功")
        return true
    }
    
    Dup_Log("所有捕获方法初始化失败")
    return false
}
```

#### DXGI初始化

**Dup_InitDXGI()**
```autohotkey
; DXGI初始化
Dup_InitDXGI() {
    try {
        ; 创建DXGI工厂
        DupEngine.DXGIFactory := DllCall("DXGI.dll\CreateDXGIFactory", "Uint", "{7b7166ec-21c7-44ae-b21a-c9e07498542e}", "Ptr*")
        if (DupEngine.DXGIFactory == 0) {
            Dup_SetLastError("创建DXGI工厂失败")
            return false
        }
        
        ; 枚举适配器
        adapter := 0
        i := 0
        while (DllCall(DupEngine.DXGIFactory "\EnumAdapters", "Uint", i, "Ptr*", &adapter) == 0) {
            ; 获取设备
            device := 0
            hr := DllCall("D3D11.dll\D3D11CreateDevice", "Ptr", adapter, "Uint", 1, "Uint", 0, "Ptr", 0, "Uint", 0x00010001, "Ptr*", &device, "Ptr", 0, "Ptr", 0)
            if (hr == 0) {
                DupEngine.Device := device
                DupEngine.Adapter := adapter
                break
            }
            i++
        }
        
        ; 枚举输出
        output := 0
        j := 0
        while (DllCall(adapter "\EnumOutputs", "Uint", j, "Ptr*", &output) == 0) {
            ; 获取输出信息
            desc := Buffer(64, 0)
            DllCall(output "\GetDesc", "Ptr", desc)
            ; 处理输出信息...
            j++
        }
        
        return true
    } catch {
        Dup_SetLastError("DXGI初始化异常")
        return false
    }
}
```

#### GDI初始化

**Dup_InitGDI()**
```autohotkey
; GDI初始化
Dup_InitGDI() {
    try {
        ; 获取桌面DC
        desktopDC := DllCall("GetDC", "Ptr", 0)
        if (desktopDC == 0) {
            Dup_SetLastError("获取桌面DC失败")
            return false
        }
        
        ; 创建兼容DC
        compatibleDC := DllCall("CreateCompatibleDC", "Ptr", desktopDC)
        if (compatibleDC == 0) {
            DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
            Dup_SetLastError("创建兼容DC失败")
            return false
        }
        
        ; 创建兼容位图
        width := A_ScreenWidth
        height := A_ScreenHeight
        compatibleBitmap := DllCall("CreateCompatibleBitmap", "Ptr", desktopDC, "Int", width, "Int", height)
        if (compatibleBitmap == 0) {
            DllCall("DeleteDC", "Ptr", compatibleDC)
            DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
            Dup_SetLastError("创建兼容位图失败")
            return false
        }
        
        ; 选择位图到DC
        oldBitmap := DllCall("SelectObject", "Ptr", compatibleDC, "Ptr", compatibleBitmap)
        
        ; 保存GDI相关信息
        DupEngine.GDI.CompatibleDC := compatibleDC
        DupEngine.GDI.CompatibleBitmap := compatibleBitmap
        DupEngine.GDI.OldBitmap := oldBitmap
        
        return true
    } catch {
        Dup_SetLastError("GDI初始化异常")
        return false
    }
}
```

#### 屏幕捕获

**Dup_CaptureScreen()**
```autohotkey
; 捕获屏幕
Dup_CaptureScreen(x := 0, y := 0, width := 0, height := 0) {
    global DupEngine
    
    if !DupEngine.Initialized {
        if !Dup_Init() {
            return 0
        }
    }
    
    if (DupEngine.Method == "DXGI") {
        return Dup_CaptureDXGI(x, y, width, height)
    } else {
        return Dup_CaptureGDI(x, y, width, height)
    }
}
```

**GDI捕获实现**:
```autohotkey
Dup_CaptureGDI(x, y, width, height) {
    global DupEngine
    
    desktopDC := DllCall("GetDC", "Ptr", 0)
    compatibleDC := DupEngine.GDI.CompatibleDC
    compatibleBitmap := DupEngine.GDI.CompatibleBitmap
    
    ; 设置捕获区域
    if (width == 0) width := A_ScreenWidth
    if (height == 0) height := A_ScreenHeight
    
    ; 执行位块传输
    result := DllCall("BitBlt", "Ptr", compatibleDC, "Int", 0, "Int", 0, "Int", width, "Int", height, "Ptr", desktopDC, "Int", x, "Int", y, "Uint", 0x00CC0020)
    
    DllCall("ReleaseDC", "Ptr", 0, "Ptr", desktopDC)
    
    if (result) {
        return compatibleBitmap
    } else {
        Dup_SetLastError("BitBlt捕获失败")
        return 0
    }
}
```

## 5. 像素检测引擎 - Pixel.ahk

### 核心功能

Pixel引擎提供高精度的像素检测和分析功能，是整个自动化系统的眼睛。

**主要特性**:
- **颜色转换**: RGB与十六进制颜色格式转换
- **颜色匹配**: 容差范围内的颜色匹配
- **多层缓存**: DXGI→ROI→GDI三级缓存系统
- **ROI快照**: 区域兴趣快照功能
- **性能优化**: 智能缓存和批量检测

### 数据结构

```autohotkey
; 像素引擎状态
PixelEngine := {
    Cache: {                // 缓存系统
        DXGI: Map(),        // DXGI帧缓存
        ROI: Map(),         // ROI区域缓存
        GDI: Map(),         // GDI位图缓存
        FrameId: 0,         // 帧ID
        LastUpdate: 0       // 最后更新时间
    },
    CurrentROI: {           // 当前ROI区域
        X: 0,
        Y: 0,
        Width: 100,
        Height: 50,
        Enabled: false
    },
    ColorFormat: "RGB"      // 颜色格式
}
```

### 核心函数

#### 颜色处理

**Pixel_ConvertColor()**
```autohotkey
; 颜色格式转换
Pixel_ConvertColor(color, fromFormat, toFormat) {
    switch fromFormat {
        case "RGB":
            return Pixel_RGBToHex(color)
        case "HEX":
            return Pixel_HexToRGB(color)
    }
    return color
}

Pixel_RGBToHex(rgb) {
    r := (rgb >> 16) & 0xFF
    g := (rgb >> 8) & 0xFF
    b := rgb & 0xFF
    return Format("0x{1:02X}{2:02X}{3:02X}", r, g, b)
}
```

#### 缓存系统

**Pixel_GetPixelFromCache()**
```autohotkey
; 从缓存获取像素
Pixel_GetPixelFromCache(x, y) {
    global PixelEngine, DupEngine
    
    ; 优先级检查：DXGI → ROI → GDI
    
    ; 1. DXGI缓存
    if DupEngine.Method == "DXGI" {
        cached := Pixel_GetDXGIFrame()
        if (cached != 0) {
            color := Pixel_ReadPixelFromDXGI(cached, x, y)
            if (color != 0) {
                return color
            }
        }
    }
    
    ; 2. ROI缓存
    if PixelEngine.CurrentROI.Enabled && Pixel_IsInROI(x, y) {
        cached := Pixel_GetROICache()
        if (cached != 0) {
            relX := x - PixelEngine.CurrentROI.X
            relY := y - PixelEngine.CurrentROI.Y
            color := Pixel_ReadPixelFromROI(cached, relX, relY)
            if (color != 0) {
                return color
            }
        }
    }
    
    ; 3. GDI缓存
    cached := Pixel_GetGDICache()
    if (cached != 0) {
        color := Pixel_ReadPixelFromGDI(cached, x, y)
        if (color != 0) {
            return color
        }
    }
    
    ; 4. 实时捕获
    return Pixel_CaptureAndRead(x, y)
}
```

#### ROI快照

**Pixel_CaptureROI()**
```autohotkey
; 捕获ROI区域
Pixel_CaptureROI() {
    global PixelEngine, DupEngine
    
    if !PixelEngine.CurrentROI.Enabled
        return 0
    
    roi := PixelEngine.CurrentROI
    
    ; 捕获指定区域
    bitmap := Dup_CaptureScreen(roi.X, roi.Y, roi.Width, roi.Height)
    if (bitmap != 0) {
        ; 缓存ROI数据
        PixelEngine.Cache.ROI.Set("Bitmap", bitmap)
        PixelEngine.Cache.ROI.Set("Width", roi.Width)
        PixelEngine.Cache.ROI.Set("Height", roi.Height)
        PixelEngine.Cache.ROI.Set("Timestamp", A_TickCount)
    }
    
    return bitmap
}
```

#### 颜色匹配

**Pixel_MatchColor()**
```autohotkey
; 颜色匹配检测
Pixel_MatchColor(x, y, expectedColor, tolerance := 0) {
    actualColor := Pixel_GetPixel(x, y)
    
    if (tolerance == 0) {
        return (actualColor == expectedColor)
    }
    
    ; 计算颜色差异
    diff := Pixel_CalculateColorDiff(actualColor, expectedColor)
    return (diff <= tolerance)
}

Pixel_CalculateColorDiff(color1, color2) {
    ; 分别计算RGB分量的差异
    r1 := (color1 >> 16) & 0xFF
    g1 := (color1 >> 8) & 0xFF
    b1 := color1 & 0xFF
    
    r2 := (color2 >> 16) & 0xFF
    g2 := (color2 >> 8) & 0xFF
    b2 := color2 & 0xFF
    
    ; 计算欧氏距离
    diff := Sqrt((r1 - r2)**2 + (g1 - g2)**2 + (b1 - b2)**2)
    return diff
}
```

## 6. 轮询调度引擎 - Poller.ahk

### 核心功能

Poller引擎是整个系统的调度中心，负责协调所有其他引擎的工作，实现高效的轮询调度。

**主要特性**:
- **优先级调度**: 按优先级顺序执行各引擎
- **状态管理**: 实时监控系统运行状态
- **故障恢复**: 自动检测和恢复故障组件
- **性能监控**: 监控各引擎的执行性能
- **资源管理**: 合理的资源分配和释放

### 数据结构

```autohotkey
; 轮询引擎状态
Poller := {
    Running: false,         // 运行状态
    Interval: 10,           // 轮询间隔（毫秒）
    LastTickTime: 0,        // 上次轮询时间
    ThreadCount: 1,         // 工作线程数
    EngineStatus: {         // 引擎状态
        BuffEngine: true,
        RotationEngine: true,
        RuleEngine: true,
        PixelEngine: true
    },
    Performance: {          // 性能统计
        TotalTicks: 0,
        AvgTickTime: 0,
        LastTickTime: 0
    }
}
```

### 核心函数

#### 主循环

**Poller_Tick()**
```autohotkey
; 轮询主循环
Poller_Tick() {
    global Poller
    
    if !Poller.Running
        return
    
    startTime := A_TickCount
    
    try {
        ; 按优先级顺序执行
        
        ; 1. Buff引擎（最高优先级）
        if Poller.EngineStatus.BuffEngine {
            Poller_RunBuffEngine()
        }
        
        ; 2. 轮换引擎或规则引擎
        if Poller.EngineStatus.RotationEngine || Poller.EngineStatus.RuleEngine {
            Poller_RunSkillEngine()
        }
        
        ; 3. 默认技能兜底
        Poller_RunDefaultSkills()
        
        ; 4. 状态重置
        Poller_ResetStates()
        
        ; 更新性能统计
        Poller_UpdatePerformance(A_TickCount - startTime)
        
    } catch error {
        Poller_HandleError("轮询异常: " . error.message)
    }
}
```

#### 引擎调度

**Poller_RunBuffEngine()**
```autohotkey
; 运行Buff引擎
Poller_RunBuffEngine() {
    try {
        BuffEngine_RunTick()
    } catch error {
        Poller_SetEngineError("BuffEngine", error.message)
    }
}

Poller_RunSkillEngine() {
    ; 优先使用轮换引擎，否则使用规则引擎
    if Poller.EngineStatus.RotationEngine {
        try {
            Rotation_RunTick()
        } catch error {
            Poller_SetEngineError("RotationEngine", error.message)
            ; 轮换引擎失败时，回退到规则引擎
            try {
                RuleEngine_RunTick()
            } catch {
                Poller_SetEngineError("RuleEngine", "规则引擎也失败")
            }
        }
    } else if Poller.EngineStatus.RuleEngine {
        try {
            RuleEngine_RunTick()
        } catch error {
            Poller_SetEngineError("RuleEngine", error.message)
        }
    }
}

Poller_RunDefaultSkills() {
    global App
    
    ; 执行默认技能序列
    if App.Has("ProfileData") && App["ProfileData"].Has("DefaultSkills") {
        defaultSkills := App["ProfileData"]["DefaultSkills"]
        
        for skill in defaultSkills {
            if Skill_IsReady(skill.Index) && Skill_ShouldUseDefault(skill) {
                WorkerPool_SendSkillIndex(1, skill.Index, "Default")
                break  ; 只执行一个默认技能
            }
        }
    }
}
```

#### 状态管理

**Poller_ResetStates()**
```autohotkey
; 重置各引擎状态
Poller_ResetStates() {
    ; 重置旋转引擎状态
    if Poller.EngineStatus.RotationEngine {
        Rotation_ResetTickState()
    }
    
    ; 重置像素缓存
    Pixel_ResetFrameCache()
    
    ; 清理临时数据
    Poller_CleanupTempData()
}
```

#### 性能监控

**Poller_UpdatePerformance()**
```autohotkey
; 更新性能统计
Poller_UpdatePerformance(tickTime) {
    global Poller
    
    Poller.Performance.TotalTicks++
    Poller.Performance.LastTickTime := tickTime
    
    ; 计算平均执行时间
    totalTime := Poller.Performance.AvgTickTime * (Poller.Performance.TotalTicks - 1)
    Poller.Performance.AvgTickTime := (totalTime + tickTime) / Poller.Performance.TotalTicks
    
    ; 检查性能警告
    if (tickTime > Poller.Interval * 0.8) {
        Poller_Log("性能警告: 轮询耗时 " tickTime "ms 超过阈值")
    }
}
```

## 引擎间协作机制

### 事件系统

**事件传递**:
```autohotkey
; 技能使用事件
Skill_NotifyUsage(skillIndex, threadId) {
    ; 通知Buff引擎
    BuffEngine_NotifySkillUsed(skillIndex)
    
    ; 更新计数器
    Counters_Inc(skillIndex)
    
    ; 通知旋转引擎
    Rotation_OnSkillUsed(skillIndex)
    
    ; 记录日志
    Poller_Log("技能使用: " skillIndex " 线程: " threadId)
}
```

### 数据共享

**全局状态管理**:
```autohotkey
; 共享技能数据
global App := {
    ProfileData: {
        Skills: [],         // 技能列表
        Rotation: {},       // 轮换配置
        Buffs: [],          // Buff配置
        Rules: []           // 规则配置
    }
}
```

### 错误恢复

**引擎故障恢复**:
```autohotkey
Poller_HandleEngineFailure(engineName, error) {
    global Poller
    
    ; 标记引擎为故障状态
    Poller.EngineStatus.%engineName% := false
    
    ; 记录错误
    Poller_Log("引擎故障: " engineName " - " error)
    
    ; 尝试重启故障引擎
    switch engineName {
        case "BuffEngine":
            Poller_RestartBuffEngine()
        case "RotationEngine":
            Poller_RestartRotationEngine()
        case "RuleEngine":
            Poller_RestartRuleEngine()
    }
}
```

## 性能优化策略

### 缓存策略

1. **DXGI缓存**: 保存整帧屏幕数据
2. **ROI缓存**: 保存感兴趣区域数据  
3. **GDI缓存**: 备用捕获数据
4. **颜色缓存**: 缓存常用颜色值

### 并发控制

1. **优先级调度**: 高优先级任务优先执行
2. **时间片分配**: 合理分配各引擎执行时间
3. **资源锁定**: 避免资源竞争
4. **异步处理**: 耗时操作异步执行

### 内存管理

1. **对象池**: 重用临时对象
2. **及时释放**: 及时释放不需要的资源
3. **内存监控**: 监控内存使用情况
4. **垃圾回收**: 主动触发垃圾回收

## 总结

引擎模块是游戏宏工具的核心组件，通过六大引擎的协同工作，实现了完整的游戏自动化功能。每个引擎都有明确的职责边界和高效的执行机制，通过事件驱动和数据共享实现模块间的无缝协作。

**核心优势**:
- ✅ 模块化设计，功能职责清晰
- ✅ 多层缓存机制，性能表现优异
- ✅ 完善的错误处理和恢复机制
- ✅ 灵活的扩展性和配置能力
- ✅ 高精度的检测和执行能力

**应用价值**:
- 为复杂游戏自动化提供可靠的技术基础
- 通过模块化实现功能的灵活组合
- 为游戏玩家提供智能化的操作体验
- 为开发者提供可扩展的自动化框架