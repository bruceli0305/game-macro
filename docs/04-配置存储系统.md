# 配置存储系统 - Configuration and Storage System Documentation

## 概述

配置存储系统是游戏宏工具的数据管理层，负责统一管理应用程序的各类配置信息、用户数据和系统状态。系统采用分层存储架构，支持多种配置格式和存储方式，提供了完整的配置读写、验证、备份和导出功能。

## 系统架构

### 核心组件

1. **Storage.ahk** - 存储管理核心模块
2. **AppConfig.ini** - 全局应用配置文件  
3. **Exporter.ahk** - 配置导出功能模块

### 存储层次结构

```
配置存储系统
├── 全局应用配置 (AppConfig.ini)
│   ├── 程序设置 (Program Settings)
│   ├── 语言设置 (Language Settings) 
│   └── UI状态 (UI State)
├── 用户配置文件 (User Profiles)
│   ├── 角色配置 (Character Profiles)
│   ├── 技能配置 (Skill Configurations)
│   ├── 点位配置 (Location Configurations)
│   ├── Buff配置 (Buff Configurations)
│   ├── 轮换轨道 (Rotation Tracks)
│   ├── 规则配置 (Rule Configurations)
│   └── 线程配置 (Thread Configurations)
└── 系统状态文件 (System State Files)
    ├── 运行状态 (Runtime State)
    ├── 临时数据 (Temporary Data)
    └── 缓存数据 (Cached Data)
```

## 1. 存储管理核心 - Storage.ahk

### 核心功能

Storage模块提供统一的配置管理接口，支持INI格式的配置文件读写和管理。

**主要特性**:
- **多配置文件管理**: 支持同时管理多个配置文件
- **结构化数据存储**: 支持复杂的嵌套配置结构
- **类型安全**: 自动类型转换和验证
- **备份机制**: 自动配置备份和恢复
- **加密支持**: 可选的配置加密功能

### 核心数据结构

```autohotkey
; 存储系统全局状态
global Storage := {
    ConfigFiles: Map(),        // 配置文件映射
    DefaultPaths: Map(),       // 默认路径映射
    LoadedProfiles: Map(),     // 已加载配置文件
    BackupDir: "",             // 备份目录
    CacheEnabled: true,        // 缓存启用状态
    Version: "1.0"            // 存储系统版本
}

; 默认路径配置
Storage.DefaultPaths := {
    AppConfig: A_ScriptDir "\AppConfig.ini",
    UserProfiles: A_ScriptDir "\config",
    BackupDir: A_ScriptDir "\backup",
    Exports: A_ScriptDir "\exports"
}

; 配置模板结构
Storage.Templates := {
    Profile: {
        General: {
            Name: "",
            Description: "",
            Created: "",
            Modified: ""
        },
        Skills: {},
        Spots: {},
        Buffs: {},
        Rules: {},
        Rotation: {}
    }
}
```

### 核心函数详解

#### 初始化存储系统

**Storage_Init()**
```autohotkey
; 初始化存储系统
Storage_Init() {
    global Storage
    
    ; 创建必要的目录
    Storage_CreateDirectories()
    
    ; 加载默认配置文件
    Storage_LoadDefaultConfig()
    
    ; 初始化备份系统
    Storage_InitBackupSystem()
    
    ; 设置默认配置
    Storage_SetDefaultValues()
    
    Storage_Log("存储系统初始化完成")
}

; 创建必要的目录
Storage_CreateDirectories() {
    dirs := [
        Storage.DefaultPaths.UserProfiles,
        Storage.DefaultPaths.BackupDir,
        Storage.DefaultPaths.Exports
    ]
    
    for dir in dirs {
        if !DirExist(dir) {
            try {
                DirCreate(dir)
                Storage_Log("创建目录: " dir)
            } catch error {
                Storage_Log("创建目录失败: " dir " - " error.message)
            }
        }
    }
}
```

#### 配置文件管理

**Storage_LoadConfig()**
```autohotkey
; 加载配置文件
Storage_LoadConfig(configName, filePath := "") {
    global Storage
    
    ; 确定文件路径
    if (filePath == "")
        filePath := Storage_ResolveConfigPath(configName)
    
    if !FileExist(filePath) {
        Storage_Log("配置文件不存在: " filePath)
        return false
    }
    
    try {
        ; 创建配置对象
        config := {}
        config.Name := configName
        config.FilePath := filePath
        config.Loaded := A_Now
        config.Checksum := Storage_CalculateChecksum(filePath)
        
        ; 读取配置节
        config.Sections := Storage_ReadAllSections(filePath)
        
        ; 缓存配置
        Storage.LoadedProfiles.Set(configName, config)
        
        Storage_Log("配置文件加载成功: " configName " -> " filePath)
        return config
    } catch error {
        Storage_Log("配置文件加载失败: " error.message)
        return false
    }
}

; 读取所有配置节
Storage_ReadAllSections(filePath) {
    sections := Map()
    
    try {
        ; 读取Ini文件的所有节
        ini := FileRead(filePath, "UTF-8")
        lines := StrSplit(ini, "`n", "`r")
        
        currentSection := ""
        
        for line in lines {
            line := Trim(line)
            
            ; 跳过注释和空行
            if (line == "" || SubStr(line, 1, 1) == ";")
                continue
            
            ; 检查节头 [SectionName]
            if (RegExMatch(line, "^\[(.+)\]$", &match)) {
                currentSection := match[1]
                sections[currentSection] := Map()
                continue
            }
            
            ; 解析键值对 Key=Value
            if (currentSection != "" && InStr(line, "=")) {
                pos := InStr(line, "=")
                key := Trim(SubStr(line, 1, pos - 1))
                value := Trim(SubStr(line, pos + 1))
                
                if (key != "")
                    sections[currentSection][key] := value
            }
        }
        
        return sections
    } catch error {
        Storage_Log("读取配置节失败: " error.message)
        return Map()
    }
}
```

**Storage_SaveConfig()**
```autohotkey
; 保存配置文件
Storage_SaveConfig(configName, configData, backup := true) {
    global Storage
    
    try {
        ; 获取配置路径
        if !Storage.LoadedProfiles.Has(configName) {
            Storage_Log("配置不存在: " configName)
            return false
        }
        
        config := Storage.LoadedProfiles[configName]
        filePath := config.FilePath
        
        ; 备份原文件
        if (backup) {
            Storage_BackupConfig(filePath)
        }
        
        ; 构建配置文件内容
        content := Storage_BuildConfigContent(configData)
        
        ; 写入文件
        FileAppend(content, filePath, "UTF-8")
        
        ; 更新配置对象
        config.Loaded := A_Now
        config.Checksum := Storage_CalculateChecksum(filePath)
        config.Modified := true
        
        Storage_Log("配置文件保存成功: " configName)
        return true
    } catch error {
        Storage_Log("配置文件保存失败: " error.message)
        return false
    }
}

; 构建配置文件内容
Storage_BuildConfigContent(configData) {
    content := ""
    
    ; 添加文件头部信息
    content .= "; 游戏宏工具配置文件`n"
    content .= "; 生成时间: " FormatTime(A_Now, "yyyy-MM-dd HH:mm:ss") "`n"
    content .= "; 版本: " Storage.Version "`n`n"
    
    ; 构建各个节
    for sectionName, sectionData in configData {
        content .= "[" sectionName "]`n"
        
        if IsObject(sectionData) {
            for key, value in sectionData {
                ; 处理不同数据类型
                if (IsObject(value)) {
                    ; 复合数据类型
                    content .= Storage_SerializeComplexData(key, value)
                } else {
                    ; 基本数据类型
                    content .= key "=" value "`n"
                }
            }
        }
        
        content .= "`n"
    }
    
    return content
}
```

#### 旋转轨道管理

**Storage_ListRotationTracks()**
```autohotkey
; 列出所有旋转轨道
Storage_ListRotationTracks(profileName := "") {
    global Storage
    
    tracks := []
    
    try {
        if (profileName != "") {
            ; 获取特定配置文件的轨道
            config := Storage_GetProfile(profileName)
            if (config && config.Sections.Has("RotationTracks")) {
                tracks := Storage_ParseRotationTracks(config.Sections["RotationTracks"])
            }
        } else {
            ; 获取所有轨道
            for configName, config in Storage.LoadedProfiles {
                if (config.Sections.Has("RotationTracks")) {
                    trackList := Storage_ParseRotationTracks(config.Sections["RotationTracks"])
                    
                    ; 为每个轨道添加配置文件信息
                    for track in trackList {
                        track.SourceConfig := configName
                        tracks.Push(track)
                    }
                }
            }
        }
        
        return tracks
    } catch error {
        Storage_Log("列出旋转轨道失败: " error.message)
        return []
    }
}

; 解析旋转轨道数据
Storage_ParseRotationTracks(sectionData) {
    tracks := []
    
    try {
        for key, value in sectionData {
            if InStr(key, "Track_") {
                track := Storage_ParseSingleTrack(value)
                track.Name := SubStr(key, 7)  ; 移除 "Track_" 前缀
                tracks.Push(track)
            }
        }
        
        return tracks
    } catch error {
        Storage_Log("解析旋转轨道失败: " error.message)
        return []
    }
}

; 解析单个轨道数据
Storage_ParseSingleTrack(trackData) {
    track := {
        Name: "",
        Steps: [],
        Enabled: true,
        Description: ""
    }
    
    try {
        ; 解析JSON格式的轨道数据
        ; 这里假设轨道数据为JSON格式
        parsed := JSON.Parse(trackData)
        
        track.Name := parsed.Has("name") ? parsed["name"] : ""
        track.Steps := parsed.Has("steps") ? parsed["steps"] : []
        track.Enabled := parsed.Has("enabled") ? parsed["enabled"] : true
        track.Description := parsed.Has("description") ? parsed["description"] : ""
        
        return track
    } catch {
        ; 备用解析方案：逗号分隔的步骤列表
        track.Steps := StrSplit(trackData, ",", " ")
        track.Name := "Unnamed_" A_TickCount
        return track
    }
}
```

#### 门配置管理

**Storage_ListGates()**
```autohotkey
; 列出所有门配置
Storage_ListGates(profileName := "") {
    global Storage
    
    gates := []
    
    try {
        if (profileName != "") {
            ; 获取特定配置文件的门
            config := Storage_GetProfile(profileName)
            if (config && config.Sections.Has("Gates")) {
                gates := Storage_ParseGates(config.Sections["Gates"])
            }
        } else {
            ; 获取所有门配置
            for configName, config in Storage.LoadedProfiles {
                if (config.Sections.Has("Gates")) {
                    gateList := Storage_ParseGates(config.Sections["Gates"])
                    
                    ; 为每个门添加配置文件信息
                    for gate in gateList {
                        gate.SourceConfig := configName
                        gates.Push(gate)
                    }
                }
            }
        }
        
        return gates
    } catch error {
        Storage_Log("列出门配置失败: " error.message)
        return []
    }
}

; 解析门配置数据
Storage_ParseGates(sectionData) {
    gates := []
    
    try {
        for key, value in sectionData {
            if InStr(key, "Gate_") {
                gate := Storage_ParseSingleGate(value)
                gate.Name := SubStr(key, 5)  ; 移除 "Gate_" 前缀
                gates.Push(gate)
            }
        }
        
        return gates
    } catch error {
        Storage_Log("解析门配置失败: " error.message)
        return []
    }
}

; 解析单个门配置
Storage_ParseSingleGate(gateData) {
    gate := {
        Name: "",
        Type: "teleport",
        Position: {x: 0, y: 0},
        Enabled: true,
        Conditions: []
    }
    
    try {
        ; 解析JSON格式的门数据
        parsed := JSON.Parse(gateData)
        
        gate.Name := parsed.Has("name") ? parsed["name"] : ""
        gate.Type := parsed.Has("type") ? parsed["type"] : "teleport"
        
        if (parsed.Has("position") && IsObject(parsed["position"])) {
            gate.Position := {
                x: parsed["position"].Has("x") ? parsed["position"]["x"] : 0,
                y: parsed["position"].Has("y") ? parsed["position"]["y"] : 0
            }
        }
        
        gate.Enabled := parsed.Has("enabled") ? parsed["enabled"] : true
        gate.Conditions := parsed.Has("conditions") ? parsed["conditions"] : []
        
        return gate
    } catch {
        ; 备用解析方案
        gate.Name := "Unnamed_" A_TickCount
        gate.Type := "teleport"
        return gate
    }
}
```

#### 完整配置文件管理

**Storage_LoadFullProfile()**
```autohotkey
; 加载完整的用户配置文件
Storage_LoadFullProfile(profileName) {
    global Storage
    
    try {
        ; 加载配置文件
        config := Storage_LoadConfig(profileName)
        if !config
            return false
        
        ; 解析各个配置节
        profile := {
            General: Storage_ParseGeneralSection(config.Sections),
            Skills: Storage_ParseSkillsSection(config.Sections),
            Spots: Storage_ParseSpotsSection(config.Sections),
            Buffs: Storage_ParseBuffsSection(config.Sections),
            Rules: Storage_ParseRulesSection(config.Sections),
            Rotation: Storage_ParseRotationSection(config.Sections),
            Threads: Storage_ParseThreadsSection(config.Sections),
            Gates: Storage_ParseGatesSection(config.Sections),
            RotationTracks: Storage_ParseRotationTracks(config.Sections)
        }
        
        ; 验证配置文件完整性
        if !Storage_ValidateProfile(profile) {
            Storage_Log("配置文件验证失败: " profileName)
            return false
        }
        
        ; 缓存完整配置文件
        Storage.FullProfiles ??= Map()
        Storage.FullProfiles[profileName] := profile
        
        Storage_Log("完整配置文件加载成功: " profileName)
        return profile
    } catch error {
        Storage_Log("加载完整配置文件失败: " error.message)
        return false
    }
}

; 解析通用设置节
Storage_ParseGeneralSection(sections) {
    general := {
        ProfileName: "",
        Description: "",
        Version: "1.0",
        Author: "",
        Created: "",
        Modified: "",
        Language: "zh-CN"
    }
    
    if sections.Has("General") {
        generalSection := sections["General"]
        
        general.ProfileName := generalSection.Has("ProfileName") ? generalSection["ProfileName"] : ""
        general.Description := generalSection.Has("Description") ? generalSection["Description"] : ""
        general.Version := generalSection.Has("Version") ? generalSection["Version"] : "1.0"
        general.Author := generalSection.Has("Author") ? generalSection["Author"] : ""
        general.Created := generalSection.Has("Created") ? generalSection["Created"] : ""
        general.Modified := generalSection.Has("Modified") ? generalSection["Modified"] : ""
        general.Language := generalSection.Has("Language") ? generalSection["Language"] : "zh-CN"
    }
    
    return general
}

; 解析技能配置节
Storage_ParseSkillsSection(sections) {
    skills := Map()
    
    if sections.Has("Skills") {
        skillsSection := sections["Skills"]
        
        for skillKey, skillValue in skillsSection {
            skill := Storage_ParseSkillData(skillValue)
            skills[skillKey] := skill
        }
    }
    
    return skills
}

; 解析单个技能数据
Storage_ParseSkillData(skillData) {
    skill := {
        Name: "",
        Type: "normal",
        Key: "",
        Cooldown: 0,
        CastTime: 0,
        ManaCost: 0,
        Enabled: true,
        Conditions: []
    }
    
    try {
        ; 尝试JSON解析
        parsed := JSON.Parse(skillData)
        
        for key, value in parsed {
            if skill.Has(key) {
                skill[key] := value
            }
        }
    } catch {
        ; 备用解析：键值对格式
        parts := StrSplit(skillData, "|")
        
        for part in parts {
            if InStr(part, "=") {
                pos := InStr(part, "=")
                key := Trim(SubStr(part, 1, pos - 1))
                value := Trim(SubStr(part, pos + 1))
                
                if skill.Has(key) {
                    ; 类型转换
                    if (key == "Cooldown" || key == "CastTime" || key == "ManaCost") {
                        skill[key] := Integer(value)
                    } else if (key == "Enabled") {
                        skill[key] := (value == "1" || value == "true")
                    } else {
                        skill[key] := value
                    }
                }
            }
        }
    }
    
    return skill
}
```

#### 备份系统

**Storage_BackupConfig()**
```autohotkey
; 备份配置文件
Storage_BackupConfig(filePath) {
    global Storage
    
    try {
        ; 生成备份文件名
        fileName := FileBase(filePath)
        ext := FileExt(filePath)
        backupName := fileName "_" FormatTime(A_Now, "yyyyMMdd_HHmmss") "." ext
        backupPath := Storage.DefaultPaths.BackupDir "\" backupName
        
        ; 复制文件进行备份
        FileCopy(filePath, backupPath, true)
        
        Storage_Log("配置文件已备份: " backupPath)
        
        ; 清理旧备份（保留最近10个）
        Storage_CleanupOldBackups(fileName)
        
        return backupPath
    } catch error {
        Storage_Log("备份配置文件失败: " error.message)
        return false
    }
}

; 清理旧备份
Storage_CleanupOldBackups(fileName) {
    global Storage
    
    try {
        backupDir := Storage.DefaultPaths.BackupDir
        pattern := backupDir "\" fileName "_*.ini"
        
        ; 获取所有匹配的备份文件
        backupFiles := []
        
        Loop Files, pattern, F  ; 文件
        {
            backupFiles.Push(A_LoopFileFullPath)
        }
        
        ; 按修改时间排序
        backupFiles.Sort()
        
        ; 保留最近的10个，删除其余的
        while (backupFiles.Length > 10) {
            oldFile := backupFiles[1]  ; 最旧的文件
            try {
                FileDelete(oldFile)
                backupFiles.RemoveAt(1)
                Storage_Log("删除旧备份: " oldFile)
            } catch {
                ; 忽略删除失败
                backupFiles.RemoveAt(1)
            }
        }
    } catch error {
        Storage_Log("清理旧备份失败: " error.message)
    }
}
```

### 辅助功能

#### 路径解析

**Storage_ResolveConfigPath()**
```autohotkey
; 解析配置文件路径
Storage_ResolveConfigPath(configName) {
    global Storage
    
    ; 检查是否为绝对路径
    if InStr(configName, ":") || SubStr(configName, 1, 1) == "\"
        return configName
    
    ; 相对路径处理
    if !Storage.DefaultPaths.Has("UserProfiles")
        Storage.DefaultPaths.UserProfiles := A_ScriptDir "\config"
    
    return Storage.DefaultPaths.UserProfiles "\" configName ".ini"
}
```

#### 校验和计算

**Storage_CalculateChecksum()**
```autohotkey
; 计算文件校验和
Storage_CalculateChecksum(filePath) {
    try {
        ; 读取文件内容
        content := FileRead(filePath)
        
        ; 简单的哈希计算（实际应用中可使用更安全的哈希算法）
        hash := 0
        for char in StrSplit(content) {
            hash += Ord(char)
        }
        
        return Format("{:08X}", hash & 0xFFFFFFFF)
    } catch {
        return "00000000"
    }
}
```

#### 日志记录

**Storage_Log()**
```autohotkey
; 存储系统日志记录
Storage_Log(message) {
    timestamp := FormatTime(A_Now, "yyyy-MM-dd HH:mm:ss")
    logEntry := "[" timestamp "] [Storage] " message "`n"
    
    try {
        ; 追加到日志文件
        logPath := A_ScriptDir "\logs\storage.log"
        if !DirExist(A_ScriptDir "\logs") {
            DirCreate(A_ScriptDir "\logs")
        }
        
        FileAppend(logEntry, logPath, "UTF-8")
    } catch {
        ; 日志记录失败不影响主功能
    }
}
```

## 2. 应用配置管理 - AppConfig.ini

### 配置结构

AppConfig.ini存储全局应用程序设置，包括程序配置、语言设置和UI状态等。

**主要配置节**:
- **[Program]** - 程序基本设置
- **[Language]** - 语言配置
- **[UI]** - 界面状态
- **[Performance]** - 性能设置
- **[Debug]** - 调试选项

### 配置示例

```ini
; 游戏宏工具 - 全局应用配置
; 生成时间: 2024-12-19 14:30:15
; 版本: 1.0

[Program]
Version=1.0.0
Name=游戏宏工具
Author=GameMacro Team
InstallPath=D:\project\AI\AHK\game-macro
DataPath=D:\project\AI\AHK\game-macro\data
LogLevel=INFO
AutoSave=true
BackupEnabled=true

[Language]
Current=zh-CN
Available=zh-CN|en-US
Default=zh-CN
ResourcePath=.\lang

[UI]
MainWindow=1
Width=1024
Height=768
Minimized=false
AlwaysOnTop=false
LanguageMenu=1

[Performance]
MaxThreads=4
WorkerPoolSize=8
CacheEnabled=true
BufferSize=1024
UpdateInterval=100

[Debug]
Enabled=false
LogToFile=true
VerboseMode=false
PerformanceMonitoring=false
```

### 配置文件读写

**配置读取函数**:
```autohotkey
; 读取程序配置
AppConfig_GetProgramSetting(key, defaultValue := "") {
    return IniRead("Program", key, defaultValue, A_ScriptDir "\AppConfig.ini")
}

; 读取语言配置
AppConfig_GetLanguageSetting(key, defaultValue := "") {
    return IniRead("Language", key, defaultValue, A_ScriptDir "\AppConfig.ini")
}

; 读取UI配置
AppConfig_GetUISetting(key, defaultValue := "") {
    return IniRead("UI", key, defaultValue, A_ScriptDir "\AppConfig.ini")
}

; 写入配置
AppConfig_SetSetting(section, key, value) {
    return IniWrite(value, section, key, A_ScriptDir "\AppConfig.ini")
}
```

## 3. 导出功能系统 - Exporter.ahk

### 核心功能

Exporter模块提供配置文件导出功能，支持将完整的配置文件和相关资源打包导出到指定目录。

**主要特性**:
- **完整导出**: 导出主脚本、配置和WorkerHost
- **目录创建**: 自动创建导出目录结构
- **文件复制**: 智能文件复制和验证
- **说明生成**: 自动生成使用说明文档
- **格式支持**: 支持多种导出格式

### 核心函数详解

#### 导出主函数

**Exporter_ExportAll()**
```autohotkey
; 导出所有组件
Exporter_ExportAll(configName, targetPath) {
    try {
        ; 验证目标路径
        if !Exporter_ValidateTargetPath(targetPath) {
            return false
        }
        
        ; 创建导出目录结构
        Exporter_CreateExportStructure(targetPath)
        
        ; 导出主脚本
        if !Exporter_ExportMainScript(targetPath) {
            Exporter_Log("主脚本导出失败")
            return false
        }
        
        ; 导出配置文件
        if !Exporter_ExportConfig(configName, targetPath) {
            Exporter_Log("配置文件导出失败")
            return false
        }
        
        ; 导出WorkerHost
        if !Exporter_ExportWorkerHost(targetPath) {
            Exporter_Log("WorkerHost导出失败")
            return false
        }
        
        ; 生成使用说明
        Exporter_GenerateReadme(targetPath, configName)
        
        Exporter_Log("导出完成: " targetPath)
        return true
    } catch error {
        Exporter_Log("导出异常: " error.message)
        return false
    }
}
```

#### 导出目录结构创建

**Exporter_CreateExportStructure()**
```autohotkey
; 创建导出目录结构
Exporter_CreateExportStructure(basePath) {
    directories := [
        basePath,
        basePath "\scripts",
        basePath "\config",
        basePath "\worker",
        basePath "\docs"
    ]
    
    for dir in directories {
        if !DirExist(dir) {
            try {
                DirCreate(dir)
                Exporter_Log("创建目录: " dir)
            } catch error {
                Exporter_Log("创建目录失败: " dir " - " error.message)
                return false
            }
        }
    }
    
    return true
}
```

#### 主脚本导出

**Exporter_ExportMainScript()**
```autohotkey
; 导出主脚本
Exporter_ExportMainScript(targetPath) {
    try {
        ; 查找主脚本文件
        mainScript := Exporter_FindMainScript()
        if !mainScript {
            Exporter_Log("未找到主脚本文件")
            return false
        }
        
        targetFile := targetPath "\scripts\" FileBase(mainScript) "." FileExt(mainScript)
        
        ; 复制主脚本
        FileCopy(mainScript, targetFile, true)
        
        ; 修改配置文件路径引用
        Exporter_UpdateConfigPath(targetFile, "..\config")
        
        Exporter_Log("主脚本导出成功: " targetFile)
        return true
    } catch error {
        Exporter_Log("主脚本导出失败: " error.message)
        return false
    }
}

; 查找主脚本
Exporter_FindMainScript() {
    ; 查找可能的脚本文件
    scriptFiles := [
        A_ScriptFullPath,
        A_ScriptDir "\main.ahk",
        A_ScriptDir "\GameMacro.ahk",
        A_ScriptDir "\macro.ahk"
    ]
    
    for scriptFile in scriptFiles {
        if FileExist(scriptFile) {
            return scriptFile
        }
    }
    
    return false
}
```

#### 配置文件导出

**Exporter_ExportConfig()**
```autohotkey
; 导出配置文件
Exporter_ExportConfig(configName, targetPath) {
    global Storage
    
    try {
        ; 获取配置对象
        config := Storage_GetProfile(configName)
        if !config {
            Exporter_Log("配置文件不存在: " configName)
            return false
        }
        
        ; 确定源配置路径
        if Storage.LoadedProfiles.Has(configName) {
            sourcePath := Storage.LoadedProfiles[configName].FilePath
        } else {
            sourcePath := Storage_ResolveConfigPath(configName)
        }
        
        targetFile := targetPath "\config\" configName ".ini"
        
        ; 复制配置文件
        FileCopy(sourcePath, targetFile, true)
        
        ; 导出相关资源文件
        Exporter_ExportResourceFiles(configName, targetPath)
        
        Exporter_Log("配置文件导出成功: " targetFile)
        return true
    } catch error {
        Exporter_Log("配置文件导出失败: " error.message)
        return false
    }
}
```

#### WorkerHost导出

**Exporter_ExportWorkerHost()**
```autohotkey
; 导出WorkerHost
Exporter_ExportWorkerHost(targetPath) {
    try {
        ; 查找WorkerHost文件
        workerHost := Exporter_FindWorkerHost()
        if !workerHost {
            Exporter_Log("未找到WorkerHost文件")
            return false
        }
        
        targetFile := targetPath "\worker\" FileBase(workerHost) "." FileExt(workerHost)
        
        ; 复制WorkerHost
        FileCopy(workerHost, targetFile, true)
        
        Exporter_Log("WorkerHost导出成功: " targetFile)
        return true
    } catch error {
        Exporter_Log("WorkerHost导出失败: " error.message)
        return false
    }
}

; 查找WorkerHost
Exporter_FindWorkerHost() {
    ; 查找WorkerHost文件（exe或ahk）
    hostFiles := []
    
    ; 搜索exe文件
    Loop Files, A_ScriptDir "\worker\*.exe" {
        hostFiles.Push(A_LoopFileFullPath)
    }
    
    ; 搜索ahk文件
    Loop Files, A_ScriptDir "\worker\*.ahk" {
        hostFiles.Push(A_LoopFileFullPath)
    }
    
    ; 返回第一个找到的文件
    return hostFiles.Length > 0 ? hostFiles[1] : false
}
```

#### 说明文档生成

**Exporter_GenerateReadme()**
```autohotkey
; 生成README说明文档
Exporter_GenerateReadme(targetPath, configName) {
    try {
        readmePath := targetPath "\README.md"
        
        ; 生成README内容
        content := Exporter_BuildReadmeContent(configName)
        
        ; 写入文件
        FileAppend(content, readmePath, "UTF-8")
        
        Exporter_Log("README生成成功: " readmePath)
        return true
    } catch error {
        Exporter_Log("README生成失败: " error.message)
        return false
    }
}

; 构建README内容
Exporter_BuildReadmeContent(configName) {
    content := ""
    content .= "# 游戏宏工具配置包`n`n"
    content .= "## 配置信息`n`n"
    content .= "- **配置文件**: " configName ".ini`n"
    content .= "- **导出时间**: " FormatTime(A_Now, "yyyy-MM-dd HH:mm:ss") "`n"
    content .= "- **版本**: 1.0`n`n"
    
    content .= "## 使用说明`n`n"
    content .= "### 1. 文件结构`n`n"
    content .= "````n"
    content .= "├── scripts/          # 主脚本文件`n"
    content .= "├── config/           # 配置文件目录`n"
    content .= "├── worker/           # WorkerHost文件`n"
    content .= "└── docs/             # 说明文档`n"
    content .= "````n`n"
    
    content .= "### 2. 使用方法`n`n"
    content .= "1. 双击运行 `scripts\`" FileBase(A_ScriptName) ".ahk` 文件`n"
    content .= "2. 配置会自动加载 `config\`" configName ".ini` 文件`n"
    content .= "3. WorkerHost位于 `worker\` 目录，用于处理后台任务`n`n"
    
    content .= "### 3. 注意事项`n`n"
    content .= "- 请确保所有文件在同一目录下`n"
    content .= "- 首次运行可能需要管理员权限`n"
    content .= "- 如有问题请查看日志文件`n`n"
    
    content .= "### 4. 配置说明`n`n"
    content .= "详细的配置选项请参考原始配置文件的注释说明。`n`n"
    
    return content
}
```

### 辅助功能

#### 路径验证

**Exporter_ValidateTargetPath()**
```autohotkey
; 验证目标路径
Exporter_ValidateTargetPath(targetPath) {
    try {
        ; 检查路径是否有效
        if targetPath == "" {
            Exporter_Log("目标路径不能为空")
            return false
        }
        
        ; 创建父目录（如果不存在）
        parentDir := DirName(targetPath)
        if !DirExist(parentDir) {
            try {
                DirCreate(parentDir)
            } catch error {
                Exporter_Log("创建父目录失败: " parentDir " - " error.message)
                return false
            }
        }
        
        ; 检查目录是否可写
        testFile := targetPath "\.write_test"
        try {
            FileAppend("", testFile)
            FileDelete(testFile)
        } catch {
            Exporter_Log("目标目录不可写: " targetPath)
            return false
        }
        
        return true
    } catch error {
        Exporter_Log("路径验证异常: " error.message)
        return false
    }
}
```

#### 配置路径更新

**Exporter_UpdateConfigPath()**
```autohotkey
; 更新配置文件路径引用
Exporter_UpdateConfigPath(scriptFile, newConfigPath) {
    try {
        ; 读取脚本内容
        content := FileRead(scriptFile, "UTF-8")
        
        ; 替换配置文件路径
        oldPatterns := [
            "A_ScriptDir",
            ".*\\config\\",
            "\.\.\\config"
        ]
        
        for pattern in oldPatterns {
            if RegExMatch(content, pattern) {
                content := RegExReplace(content, pattern, newConfigPath)
                break
            }
        }
        
        ; 写回文件
        FileDelete(scriptFile)
        FileAppend(content, scriptFile, "UTF-8")
        
        return true
    } catch error {
        Exporter_Log("更新配置路径失败: " error.message)
        return false
    }
}
```

#### 日志记录

**Exporter_Log()**
```autohotkey
; 导出系统日志记录
Exporter_Log(message) {
    timestamp := FormatTime(A_Now, "yyyy-MM-dd HH:mm:ss")
    logEntry := "[" timestamp "] [Exporter] " message "`n"
    
    try {
        ; 追加到日志文件
        logPath := A_ScriptDir "\logs\exporter.log"
        if !DirExist(A_ScriptDir "\logs") {
            DirCreate(A_ScriptDir "\logs")
        }
        
        FileAppend(logEntry, logPath, "UTF-8")
    } catch {
        ; 日志记录失败不影响主功能
    }
}
```

## 4. 配置验证与安全

### 配置验证机制

**完整性检查**:
```autohotkey
; 验证配置文件完整性
Storage_ValidateProfile(profile) {
    requiredSections := ["General", "Skills", "Spots"]
    
    ; 检查必需的配置节
    for section in requiredSections {
        if !profile.Has(section) {
            Storage_Log("缺少必需配置节: " section)
            return false
        }
    }
    
    ; 验证数据类型
    if !Storage_ValidateDataTypes(profile) {
        return false
    }
    
    ; 验证业务逻辑
    if !Storage_ValidateBusinessRules(profile) {
        return false
    }
    
    return true
}

; 验证数据类型
Storage_ValidateDataTypes(profile) {
    try {
        ; 验证数值类型
        for sectionName, sectionData in profile {
            for key, value in sectionData {
                if (key == "Cooldown" || key == "CastTime") {
                    if !IsNumber(value) {
                        Storage_Log("无效数值类型: " sectionName "." key)
                        return false
                    }
                }
            }
        }
        
        return true
    } catch {
        return false
    }
}
```

### 安全机制

**数据加密**:
```autohotkey
; 加密敏感配置数据
Storage_EncryptSensitiveData(data) {
    ; 这里可以实现数据加密逻辑
    ; 使用对称加密算法保护敏感信息
    ; 返回加密后的数据
    return data
}

; 解密敏感配置数据
Storage_DecryptSensitiveData(encryptedData) {
    ; 对应的解密逻辑
    ; 返回解密后的数据
    return encryptedData
}
```

## 5. 性能优化

### 缓存机制

**配置缓存**:
```autohotkey
; 启用配置缓存
Storage_EnableCache() {
    global Storage
    
    Storage.CacheEnabled := true
    Storage.Cache := Map()
    
    Storage_Log("配置缓存已启用")
}

; 缓存配置数据
Storage_CacheConfig(configName, data) {
    global Storage
    
    if Storage.CacheEnabled && Storage.Cache.Has(configName) {
        Storage.Cache[configName] := {
            Data: data,
            Timestamp: A_TickCount,
            TTL: 300000  ; 5分钟缓存
        }
    }
}
```

### 异步加载

**后台加载**:
```autohotkey
; 异步加载配置文件
Storage_LoadConfigAsync(configName, callback) {
    ; 创建异步任务
    task := { ConfigName: configName, Callback: callback }
    
    ; 放入异步队列
    Storage.AsyncQueue ??= []
    Storage.AsyncQueue.Push(task)
    
    ; 启动异步处理
    if !Storage.AsyncProcessing {
        Storage_ProcessAsyncQueue()
    }
}
```

## 总结

配置存储系统提供了完整的配置管理解决方案，具备以下核心能力：

**核心优势**:
- ✅ 分层存储架构，支持多种配置格式
- ✅ 完整的CRUD操作和事务支持
- ✅ 自动备份和恢复机制
- ✅ 类型安全和数据验证
- ✅ 性能优化和缓存支持
- ✅ 灵活的导出和部署功能

**技术特性**:
- **多文件管理**: 支持同时管理多个配置文件
- **结构化存储**: 复杂的嵌套配置结构支持
- **热更新**: 无需重启的配置热更新
- **版本控制**: 配置文件的版本管理
- **安全保护**: 敏感数据加密和安全验证

**应用价值**:
- 为游戏宏工具提供可靠的数据持久化方案
- 支持复杂的角色配置和技能管理需求
- 提供完整的配置备份和恢复保障
- 实现灵活的配置文件导出和部署机制
- 支持多用户、多配置的并发管理

**扩展建议**:
- 增加数据库存储支持（SQLite/MySQL）
- 实现配置模板和快速生成功能
- 添加配置版本控制和变更追踪
- 支持云端配置同步和备份
- 实现更丰富的配置验证规则