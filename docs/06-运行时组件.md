# 运行时组件 - Runtime Components Documentation

## 概述

运行时组件是游戏宏工具的核心支撑系统，负责在程序运行期间提供基础功能服务、状态管理、数据处理和系统协调。系统包含计数器管理、BUFF引擎、工作池控制、线程管理、工具类函数等核心模块，为整个应用提供稳定可靠的运行时环境。

## 系统架构

### 核心组件

1. **Counters.ahk** - 计数器管理系统
2. **BuffEngine.ahk** - BUFF持续管理引擎
3. **WorkerPool.ahk** - 工作池主控制器
4. **GUI_Threads.ahk** - 线程配置管理
5. **Utils.ahk** - 通用工具函数
6. **Hotkeys.ahk** - 热键运行时管理

### 系统架构图

```
运行时组件系统
├── 计数管理 (Counters)
│   ├── Map数据存储 (Map Storage)
│   ├── 原子操作 (Atomic Operations)  
│   ├── 批量操作 (Batch Operations)
│   └── 生命周期管理 (Lifecycle Management)
├── BUFF引擎 (BuffEngine)
│   ├── 持续时间管理 (Duration Management)
│   ├── 就绪检测 (Ready Detection)
│   ├── 轮转算法 (Rotation Algorithm)
│   └── 线程协调 (Thread Coordination)
├── 工作池控制器 (WorkerPool)
│   ├── 进程管理 (Process Management)
│   ├── 施法锁 (Cast Lock System)
│   ├── 技能分发 (Skill Dispatch)
│   └── 性能监控 (Performance Monitoring)
├── 线程管理 (Thread Management)
│   ├── 配置管理 (Configuration Management)
│   ├── 引用检查 (Reference Checking)
│   ├── UI交互 (UI Interaction)
│   └── 状态同步 (State Synchronization)
└── 工具函数库 (Utilities)
    ├── 消息提示 (Notification System)
    ├── 确认对话框 (Confirmation Dialogs)
    ├── 窗口管理 (Window Management)
    └── 数据处理 (Data Processing)
```

## 1. 计数器系统 - Counters.ahk

### 核心功能

计数器系统提供轻量级、高性能的计数器管理服务，支持原子操作、批量处理和生命周期管理。

**主要特性**:
- **Map存储**: 使用AutoHotkey v2的Map数据结构
- **原子操作**: 线程安全的递增操作
- **批量重置**: 支持多个计数器同时重置
- **轻量设计**: 零依赖，小体积高性能

### 核心数据结构

```autohotkey
; 计数器全局对象
global Counters := Map()

; 计数器结构
CounterItem := {
    Value: 0,              ; 当前值
    LastUpdate: 0,         ; 最后更新时间
    Type: "general",       ; 计数器类型
    Metadata: {}           ; 元数据
}

; 计数器配置
CountersConfig := {
    MaxCounters: 1000,     ; 最大计数器数量
    AutoCleanup: true,     ; 自动清理
    CleanupInterval: 60000 ; 清理间隔(毫秒)
}
```

### 核心函数详解

#### 系统初始化

**Counters_Init()**
```autohotkey
; 初始化计数器系统
Counters_Init() {
    global Counters
    
    try {
        ; 创建新的Map实例
        Counters := Map()
        
        ; 初始化预定义计数器
        Counters_InitPredefined()
        
        ; 启动定期清理
        SetTimer(Counters_Cleanup, 60000)  ; 每分钟清理
        
        Counters_Log("计数器系统初始化完成")
        return true
    } catch error {
        Counters_Log("计数器系统初始化失败: " error.message)
        return false
    }
}

; 初始化预定义计数器
Counters_InitPredefined() {
    global Counters
    
    ; 创建基础计数器
    predefinedCounters := {
        "total_skills": { Value: 0, Type: "skill", Description: "总技能执行次数" },
        "successful_skills": { Value: 0, Type: "skill", Description: "成功技能执行次数" },
        "failed_skills": { Value: 0, Type: "skill", Description: "失败技能执行次数" },
        "buff_activations": { Value: 0, Type: "buff", Description: "BUFF激活次数" },
        "rule_executions": { Value: 0, Type: "rule", Description: "规则执行次数" },
        "ui_interactions": { Value: 0, Type: "ui", Description: "UI交互次数" },
        "errors": { Value: 0, Type: "error", Description: "错误计数" },
        "warnings": { Value: 0, Type: "warning", Description: "警告计数" }
    }
    
    for name, data in predefinedCounters {
        Counters[name] := {
            Value: 0,
            LastUpdate: A_TickCount,
            Type: data.Type,
            Description: data.Description,
            Created: A_TickCount
        }
    }
}
```

#### 原子操作

**Counters_Inc()**
```autohotkey
; 原子递增操作
Counters_Inc(idx, increment := 1, metadata := "") {
    global Counters
    
    try {
        ; 确保计数器存在
        if !Counters.Has(idx) {
            Counters[idx] := {
                Value: 0,
                LastUpdate: 0,
                Type: "general",
                Metadata: {},
                Created: A_TickCount
            }
        }
        
        ; 原子递增（AutoHotkey v2的Map操作是原子的）
        current := Counters[idx]
        current.Value += increment
        current.LastUpdate := A_TickCount
        
        ; 可选添加元数据
        if (metadata != "") {
            current.Metadata[A_TickCount] := metadata
        }
        
        ; 清理过期元数据（保持最多100条）
        if (current.Metadata.Count > 100) {
            oldestKey := current.Metadata.MinIndex()
            current.Metadata.Delete(oldestKey)
        }
        
        return current.Value
    } catch error {
        Counters_Log("计数器递增失败: " error.message)
        return false
    }
}

; 安全递增（带类型检查）
Counters_IncSafe(idx, increment := 1, expectedType := "general") {
    global Counters
    
    try {
        ; 类型检查
        if (increment != Integer(increment)) {
            Counters_Log("递增量必须是整数")
            return false
        }
        
        if (Counters.Has(idx)) {
            current := Counters[idx]
            if (expectedType != "general" && current.Type != expectedType) {
                Counters_Log("计数器类型不匹配: " idx)
                return false
            }
        }
        
        return Counters_Inc(idx, increment)
    } catch error {
        Counters_Log("安全递增失败: " error.message)
        return false
    }
}
```

#### 数据获取

**Counters_Get()**
```autohotkey
; 获取计数器值
Counters_Get(idx, defaultValue := 0) {
    global Counters
    
    try {
        if Counters.Has(idx) {
            counter := Counters[idx]
            return counter.Value
        } else {
            return defaultValue
        }
    } catch error {
        Counters_Log("获取计数器失败: " error.message)
        return defaultValue
    }
}

; 获取计数器详细信息
Counters_GetInfo(idx) {
    global Counters
    
    try {
        if Counters.Has(idx) {
            counter := Counters[idx]
            return {
                Value: counter.Value,
                LastUpdate: counter.LastUpdate,
                Type: counter.Type,
                Metadata: counter.Metadata,
                Created: counter.Created,
                Age: A_TickCount - counter.Created
            }
        } else {
            return {
                Exists: false,
                Value: 0,
                Type: "unknown",
                Age: 0
            }
        }
    } catch error {
        Counters_Log("获取计数器信息失败: " error.message)
        return false
    }
}

; 获取所有计数器统计
Counters_GetStatistics() {
    global Counters
    
    try {
        stats := {
            TotalCounters: Counters.Count(),
            TotalValue: 0,
            TypeDistribution: {},
            OldestCounter: { Age: 0, Name: "" },
            NewestUpdate: { Age: 0, Name: "" }
        }
        
        currentTime := A_TickCount
        oldestAge := 0
        newestAge := 0
        
        for name, counter in Counters {
            ; 统计总值
            stats.TotalValue += counter.Value
            
            ; 统计类型分布
            if !stats.TypeDistribution.Has(counter.Type) {
                stats.TypeDistribution[counter.Type] := 0
            }
            stats.TypeDistribution[counter.Type]++
            
            ; 查找最老计数器
            age := currentTime - counter.Created
            if (age > oldestAge) {
                oldestAge := age
                stats.OldestCounter.Name := name
                stats.OldestCounter.Age := age
            }
            
            ; 查找最新更新
            updateAge := currentTime - counter.LastUpdate
            if (updateAge < newestAge || newestAge == 0) {
                newestAge := updateAge
                stats.NewestUpdate.Name := name
                stats.NewestUpdate.Age := updateAge
            }
        }
        
        return stats
    } catch error {
        Counters_Log("获取统计信息失败: " error.message)
        return {}
    }
}
```

#### 重置操作

**Counters_Reset()**
```autohotkey
; 重置单个计数器
Counters_Reset(idx, preserveMetadata := false) {
    global Counters
    
    try {
        if Counters.Has(idx) {
            if (preserveMetadata) {
                ; 保留元数据，只重置值
                counter := Counters[idx]
                counter.Value := 0
                counter.LastUpdate := A_TickCount
            } else {
                ; 完全删除
                Counters.Delete(idx)
            }
            
            Counters_Log("计数器重置完成: " idx)
            return true
        } else {
            Counters_Log("计数器不存在: " idx)
            return false
        }
    } catch error {
        Counters_Log("重置计数器失败: " error.message)
        return false
    }
}

; 批量重置
Counters_ResetMany(indices, preserveMetadata := false) {
    global Counters
    
    try {
        successCount := 0
        failedCount := 0
        
        for _, idx in indices {
            if Counters_Reset(idx, preserveMetadata) {
                successCount++
            } else {
                failedCount++
            }
        }
        
        Counters_Log("批量重置完成: 成功 " successCount " 个，失败 " failedCount " 个")
        return { Success: successCount, Failed: failedCount }
    } catch error {
        Counters_Log("批量重置失败: " error.message)
        return false
    }
}

; 按类型重置
Counters_ResetByType(typeName, preserveMetadata := false) {
    global Counters
    
    try {
        resetList := []
        
        for name, counter in Counters {
            if (counter.Type == typeName) {
                resetList.Push(name)
            }
        }
        
        if (resetList.Length > 0) {
            return Counters_ResetMany(resetList, preserveMetadata)
        } else {
            Counters_Log("未找到指定类型的计数器: " typeName)
            return { Success: 0, Failed: 0 }
        }
    } catch error {
        Counters_Log("按类型重置失败: " error.message)
        return false
    }
}
```

#### 生命周期管理

**Counters_Cleanup()**
```autohotkey
; 定期清理过期计数器
Counters_Cleanup() {
    global Counters
    
    try {
        currentTime := A_TickCount
        expiredList := []
        
        ; 清理过期计数器（超过1小时未更新）
        for name, counter in Counters {
            if (currentTime - counter.LastUpdate > 3600000) {  ; 1小时
                expiredList.Push(name)
            }
        }
        
        ; 删除过期计数器
        for name in expiredList {
            Counters.Delete(name)
        }
        
        ; 清理计数器元数据
        Counters_CleanupMetadata()
        
        if (expiredList.Length > 0) {
            Counters_Log("清理完成：删除 " expiredList.Length " 个过期计数器")
        }
        
        return expiredList.Length
    } catch error {
        Counters_Log("清理失败: " error.message)
        return 0
    }
}

; 清理元数据
Counters_CleanupMetadata() {
    global Counters
    
    for name, counter in Counters {
        if (counter.Has("Metadata") && counter.Metadata.Count > 50) {
            ; 保留最近的50条元数据
            keys := []
            for key in counter.Metadata {
                keys.Push(key)
            }
            
            ; 按时间排序并删除多余的
            keys.Sort()
            excessCount := keys.Length - 50
            loop excessCount {
                counter.Metadata.Delete(keys[A_Index])
            }
        }
    }
}

; 强制内存清理
Counters_ForceGarbageCollection() {
    global Counters
    
    try {
        ; 强制重新创建Map以触发垃圾回收
        oldCounters := Counters
        Counters := Map()
        
        ; 保留重要计数器
        for name, counter in oldCounters {
            if (counter.Value > 0 || counter.Type == "critical") {
                Counters[name] := counter
            }
        }
        
        Counters_Log("强制垃圾回收完成，保留计数器数量: " Counters.Count())
        return true
    } catch error {
        Counters_Log("强制垃圾回收失败: " error.message)
        return false
    }
}
```

## 2. BUFF引擎 - BuffEngine.ahk

### 核心功能

BUFF引擎负责管理游戏中的增益效果持续时间，提供智能续BUFF、就绪检测、轮转算法等核心功能。

**主要特性**:
- **持续时间管理**: 精确的BUFF持续时间跟踪
- **智能续BUFF**: 基于剩余时间的优先续BUFF策略
- **就绪检测**: 可选的像素就绪状态检测
- **轮转算法**: 支持技能轮转避免固定使用
- **线程协调**: 多线程环境下的协调执行

### 核心数据结构

```autohotkey
; BUFF配置结构
BuffConfig := {
    Id: 0,                        ; BUFF ID
    Name: "",                     ; BUFF名称
    Enabled: true,                ; 是否启用
    ThreadId: 1,                  ; 所属线程ID
    Skills: [],                   ; 技能索引数组
    DurationMs: 0,               ; 持续时间(毫秒)
    RefreshBeforeMs: 0,          ; 提前续BUFF时间(毫秒)
    CheckReady: true,            ; 是否检测就绪
    NextIdx: 1,                  ; 下一个技能索引
    LastTime: 0,                 ; 最后激活时间
    Priority: 0,                 ; 优先级
    Metadata: {}                 ; 元数据
}

; BUFF引擎状态
BuffEngineState := {
    IsRunning: false,            ; 是否运行中
    LastTick: 0,                 ; 最后执行时间
    ExecutionCount: 0,           ; 执行次数
    BuffActivations: 0,          ; BUFF激活次数
    SkillSendSuccess: 0,         ; 技能发送成功次数
    SkillSendFailed: 0,          ; 技能发送失败次数
    CacheHitRate: 0.0,           ; 缓存命中率
    PerformanceMetrics: {}       ; 性能指标
}
```

### 核心函数详解

#### 系统初始化

**BuffEngine_Init()**
```autohotkey
; 初始化BUFF引擎
BuffEngine_Init() {
    global BuffEngineState
    
    try {
        ; 初始化状态
        BuffEngineState := {
            IsRunning: false,
            LastTick: 0,
            ExecutionCount: 0,
            BuffActivations: 0,
            SkillSendSuccess: 0,
            SkillSendFailed: 0,
            CacheHitRate: 0.0,
            PerformanceMetrics: {
                AverageTickTime: 0,
                LastTickTime: 0,
                MaxTickTime: 0,
                MinTickTime: 999999
            }
        }
        
        ; 启动性能监控
        SetTimer(BuffEngine_PerformanceMonitor, 1000)
        
        BuffEngine_Log("BUFF引擎初始化完成")
        return true
    } catch error {
        BuffEngine_Log("BUFF引擎初始化失败: " error.message)
        return false
    }
}

; 启动BUFF引擎
BuffEngine_Start() {
    global BuffEngineState
    
    try {
        BuffEngineState.IsRunning := true
        BuffEngine_Log("BUFF引擎已启动")
        return true
    } catch error {
        BuffEngine_Log("BUFF引擎启动失败: " error.message)
        return false
    }
}

; 停止BUFF引擎
BuffEngine_Stop() {
    global BuffEngineState
    
    try {
        BuffEngineState.IsRunning := false
        BuffEngine_Log("BUFF引擎已停止")
        return true
    } catch error {
        BuffEngine_Log("BUFF引擎停止失败: " error.message)
        return false
    }
}
```

#### 主执行循环

**BuffEngine_RunTick()**
```autohotkey
; BUFF引擎主循环
BuffEngine_RunTick() {
    global App, BuffEngineState
    
    try {
        if (!BuffEngineState.IsRunning) {
            return false
        }
        
        startTime := A_TickCount
        
        ; 获取配置文件
        prof := App["ProfileData"]
        if !HasProp(prof, "Buffs") || (prof.Buffs.Length = 0) {
            return false
        }
        
        ; 遍历所有BUFF配置
        activated := false
        for _, b in prof.Buffs {
            if (BuffEngine_ProcessSingleBuff(b, prof)) {
                activated := true
                BuffEngineState.BuffActivations++
                break  ; 每tick只处理一个BUFF
            }
        }
        
        ; 更新性能指标
        executionTime := A_TickCount - startTime
        BuffEngine_UpdatePerformanceMetrics(executionTime)
        
        return activated
    } catch error {
        BuffEngine_Log("BUFF引擎执行异常: " error.message)
        return false
    }
}

; 处理单个BUFF配置
BuffEngine_ProcessSingleBuff(buffConfig, profileData) {
    try {
        ; 基本校验
        if !BuffEngine_ValidateBuffConfig(buffConfig) {
            return false
        }
        
        ; 检查是否需要续BUFF
        if !BuffEngine_NeedsRefresh(buffConfig) {
            return false
        }
        
        ; 获取线程ID
        thrId := HasProp(buffConfig, "ThreadId") ? buffConfig.ThreadId : 1
        
        ; 尝试执行技能
        return BuffEngine_TryExecuteSkill(buffConfig, profileData, thrId)
    } catch error {
        BuffEngine_Log("处理BUFF异常: " error.message)
        return false
    }
}

; 验证BUFF配置
BuffEngine_ValidateBuffConfig(buffConfig) {
    ; 检查必要字段
    if !buffConfig.Has("Enabled") || !buffConfig.Enabled {
        return false
    }
    
    if !buffConfig.Has("Skills") || buffConfig.Skills.Length == 0 {
        return false
    }
    
    ; 检查持续时间
    duration := HasProp(buffConfig, "DurationMs") ? buffConfig.DurationMs : 0
    if (duration <= 0) {
        return false
    }
    
    return true
}

; 检查是否需要续BUFF
BuffEngine_NeedsRefresh(buffConfig) {
    now := A_TickCount
    duration := HasProp(buffConfig, "DurationMs") ? buffConfig.DurationMs : 0
    refreshBefore := HasProp(buffConfig, "RefreshBeforeMs") ? buffConfig.RefreshBeforeMs : 0
    
    ; 获取最后激活时间
    last := HasProp(buffConfig, "LastTime") ? buffConfig.LastTime : 0
    
    ; 计算已过时间
    elapsed := (last == 0) ? duration : (now - last)
    
    ; 判断是否需要续BUFF
    ; 情况1: 从未激活过 (last == 0)
    ; 情况2: 剩余时间少于阈值 (duration - elapsed <= refreshBefore)
    needRefresh := (last == 0) || (duration - elapsed <= refreshBefore)
    
    if (needRefresh) {
        BuffEngine_Log(Format("BUFF需要续: {1}, 剩余: {2}ms", buffConfig.Name, duration - elapsed))
    }
    
    return needRefresh
}
```

#### 技能执行

**BuffEngine_TryExecuteSkill()**
```autohotkey
; 尝试执行技能
BuffEngine_TryExecuteSkill(buffConfig, profileData, threadId) {
    try {
        ; 轮转算法：避免固定使用同一技能
        if !BuffEngine_UpdateRotationIndex(buffConfig) {
            return false
        }
        
        totalSkills := buffConfig.Skills.Length
        tryCount := 0
        
        ; 尝试执行技能（轮转模式）
        while (tryCount < totalSkills) {
            slot := buffConfig.NextIdx
            buffConfig.NextIdx := (slot >= totalSkills) ? 1 : (slot + 1)
            tryCount++
            
            idx := buffConfig.Skills[slot]
            
            ; 验证技能索引
            if !BuffEngine_ValidateSkillIndex(idx, profileData) {
                continue
            }
            
            skillData := profileData.Skills[idx]
            
            ; 可选：像素就绪检测
            if (buffConfig.CheckReady = 1) {
                if !BuffEngine_CheckSkillReady(skillData) {
                    continue
                }
            }
            
            ; 发送技能
            if BuffEngine_SendSkill(threadId, idx, buffConfig.Name, skillData.Name) {
                ; 更新BUFF状态
                buffConfig.LastTime := A_TickCount
                
                ; 更新计数器
                Counters_Inc("buff_activations")
                Counters_Inc("buff_" buffConfig.Name "_activations")
                
                return true
            }
        }
        
        return false
    } catch error {
        BuffEngine_Log("执行技能异常: " error.message)
        return false
    }
}

; 更新轮转索引
BuffEngine_UpdateRotationIndex(buffConfig) {
    try {
        if !buffConfig.Has("NextIdx") {
            buffConfig.NextIdx := 1
        }
        
        if (buffConfig.NextIdx < 1 || buffConfig.NextIdx > buffConfig.Skills.Length) {
            buffConfig.NextIdx := 1
        }
        
        return true
    } catch error {
        BuffEngine_Log("更新轮转索引失败: " error.message)
        return false
    }
}

; 验证技能索引
BuffEngine_ValidateSkillIndex(idx, profileData) {
    try {
        if (idx < 1 || idx > profileData.Skills.Length) {
            BuffEngine_Log("技能索引越界: " idx)
            return false
        }
        
        return true
    } catch error {
        BuffEngine_Log("验证技能索引异常: " error.message)
        return false
    }
}

; 检查技能就绪状态
BuffEngine_CheckSkillReady(skillData) {
    try {
        cur := Pixel_FrameGet(skillData.X, skillData.Y)
        tgt := Pixel_HexToInt(skillData.Color)
        
        isReady := Pixel_ColorMatch(cur, tgt, skillData.Tol)
        
        if (!isReady) {
            BuffEngine_Log(Format("技能未就绪: {1}", skillData.Name))
        }
        
        return isReady
    } catch error {
        BuffEngine_Log("检查技能就绪异常: " error.message)
        return false
    }
}

; 发送技能
BuffEngine_SendSkill(threadId, idx, buffName, skillName) {
    try {
        source := "Buff:" buffName
        result := WorkerPool_SendSkillIndex(threadId, idx, source)
        
        if (result) {
            BuffEngineState.SkillSendSuccess++
            BuffEngine_Log(Format("BUFF技能发送成功: {1} -> 线程{2}", skillName, threadId))
        } else {
            BuffEngineState.SkillSendFailed++
            BuffEngine_Log(Format("BUFF技能发送失败: {1} -> 线程{2}", skillName, threadId))
        }
        
        return result
    } catch error {
        BuffEngineState.SkillSendFailed++
        BuffEngine_Log("发送技能异常: " error.message)
        return false
    }
}
```

#### 技能通知处理

**BuffEngine_NotifySkillUsed()**
```autohotkey
; 技能使用通知
BuffEngine_NotifySkillUsed(idx, source := "") {
    global App
    
    try {
        if !HasProp(App["ProfileData"], "Buffs") {
            return
        }
        
        now := A_TickCount
        updatedBuffs := 0
        
        for _, b in App["ProfileData"].Buffs {
            if !HasProp(b, "Skills") {
                continue
            }
            
            ; 检查技能是否在BUFF的技能列表中
            skillIndex := BuffEngine_FindSkillInBuff(b.Skills, idx)
            if (skillIndex > 0) {
                ; 更新BUFF时间
                b.LastTime := now
                
                ; 更新轮转指针
                BuffEngine_UpdateBuffRotation(b, skillIndex)
                
                ; 更新统计
                Counters_Inc("buff_skill_notifications")
                
                updatedBuffs++
                
                BuffEngine_Log(Format("BUFF技能通知: 技能#{1} 更新BUFF '{2}'", idx, b.Name))
            }
        }
        
        if (updatedBuffs > 0) {
            BuffEngine_Log(Format("技能通知处理完成: 技能#{1} 更新 {2} 个BUFF", idx, updatedBuffs))
        }
        
        return updatedBuffs
    } catch error {
        BuffEngine_Log("技能通知处理异常: " error.message)
        return 0
    }
}

; 在BUFF技能列表中查找技能索引
BuffEngine_FindSkillInBuff(buffSkills, targetIdx) {
    for i, idx in buffSkills {
        if (idx == targetIdx) {
            return i
        }
    }
    return 0
}

; 更新BUFF轮转
BuffEngine_UpdateBuffRotation(buffConfig, skillIndex) {
    try {
        if !buffConfig.Has("NextIdx") {
            buffConfig.NextIdx := 1
        }
        
        ; 轻微推进轮转指针，避免固定使用
        buffConfig.NextIdx := (buffConfig.NextIdx >= buffConfig.Skills.Length) ? 1 : (buffConfig.NextIdx + 1)
        
        ; 更新元数据
        if !buffConfig.Has("Metadata") {
            buffConfig.Metadata := {}
        }
        
        buffConfig.Metadata[A_TickCount] := {
            Action: "skill_notification",
            SkillIndex: skillIndex,
            NextIdx: buffConfig.NextIdx
        }
        
        ; 保持元数据不超过100条
        if (buffConfig.Metadata.Count > 100) {
            oldestKey := buffConfig.Metadata.MinIndex()
            buffConfig.Metadata.Delete(oldestKey)
        }
    } catch error {
        BuffEngine_Log("更新BUFF轮转异常: " error.message)
    }
}
```

#### 性能监控

**BuffEngine_UpdatePerformanceMetrics()**
```autohotkey
; 更新性能指标
BuffEngine_UpdatePerformanceMetrics(executionTime) {
    global BuffEngineState
    
    try {
        metrics := BuffEngineState.PerformanceMetrics
        
        ; 更新执行时间统计
        metrics.LastTickTime := executionTime
        
        ; 更新最小/最大时间
        if (executionTime < metrics.MinTickTime) {
            metrics.MinTickTime := executionTime
        }
        if (executionTime > metrics.MaxTickTime) {
            metrics.MaxTickTime := executionTime
        }
        
        ; 更新平均时间
        totalTime := metrics.AverageTickTime * (BuffEngineState.ExecutionCount - 1) + executionTime
        metrics.AverageTickTime := totalTime / BuffEngineState.ExecutionCount
        
        ; 更新成功率
        totalAttempts := BuffEngineState.SkillSendSuccess + BuffEngineState.SkillSendFailed
        if (totalAttempts > 0) {
            BuffEngineState.PerformanceMetrics.SuccessRate := 
                BuffEngineState.SkillSendSuccess / totalAttempts * 100
        }
    } catch error {
        BuffEngine_Log("更新性能指标异常: " error.message)
    }
}

; 性能监控定时器
BuffEngine_PerformanceMonitor() {
    global BuffEngineState
    
    try {
        if (!BuffEngineState.IsRunning) {
            return
        }
        
        ; 记录当前状态
        currentStats := {
            IsRunning: BuffEngineState.IsRunning,
            ExecutionCount: BuffEngineState.ExecutionCount,
            BuffActivations: BuffEngineState.BuffActivations,
            SkillSuccessRate: BuffEngineState.PerformanceMetrics.SuccessRate,
            AverageTickTime: BuffEngineState.PerformanceMetrics.AverageTickTime
        }
        
        ; 定期输出性能报告（可选）
        if (Mod(A_TickCount, 60000) == 0) {  ; 每分钟
            BuffEngine_Log("BUFF引擎性能报告:")
            BuffEngine_Log("  执行次数: " currentStats.ExecutionCount)
            BuffEngine_Log("  BUFF激活: " currentStats.BuffActivations)
            BuffEngine_Log("  成功率: " Round(currentStats.SkillSuccessRate, 2) "%")
            BuffEngine_Log("  平均执行时间: " currentStats.AverageTickTime "ms")
        }
    } catch error {
        ; 忽略监控异常
    }
}
```

## 3. 线程管理系统 - GUI_Threads.ahk

### 核心功能

线程管理系统负责管理多进程池中的线程配置，提供UI交互、配置验证、引用检查等核心功能。

**主要特性**:
- **配置管理**: 线程信息的增删改查
- **引用检查**: 检查线程被规则/BUFF的引用情况
- **UI交互**: 直观的图形界面操作
- **状态同步**: 与工作池的实时状态同步

### 核心数据结构

```autohotkey
; 线程配置结构
ThreadConfig := {
    Id: 0,                      ; 线程ID
    Name: "",                   ; 线程名称
    Enabled: true,              ; 是否启用
    Priority: 0,                ; 优先级
    MaxConcurrent: 1,           ; 最大并发数
    Created: 0,                 ; 创建时间
    Modified: 0,                ; 修改时间
    Metadata: {}                ; 元数据
}

; 线程引用统计
ThreadReferences := {
    Rules: [],                  ; 引用的规则
    Buffs: [],                  ; 引用的BUFF
    TotalReferences: 0,         ; 总引用数
    LastCheck: 0                ; 最后检查时间
}
```

### 核心函数详解

#### 系统初始化

**ThreadsManager_Show()**
```autohotkey
; 显示线程管理对话框
ThreadsManager_Show() {
    global App
    
    try {
        ; 创建对话框
        dlg := Gui("+Owner" UI.Main.Hwnd, "线程配置（工作进程池）")
        dlg.SetFont("s10", "Segoe UI")
        dlg.MarginX := 12
        dlg.MarginY := 10
        
        ; 创建控件
        ThreadsManager_CreateControls(dlg)
        
        ; 绑定事件
        ThreadsManager_BindEvents()
        
        ; 初始化数据
        ThreadsManager_InitializeData()
        
        ; 显示对话框
        dlg.Show()
        
        ThreadsManager_Log("线程管理对话框已显示")
        return dlg
    } catch error {
        ThreadsManager_Log("显示线程管理对话框失败: " error.message)
        return false
    }
}

; 创建控件
ThreadsManager_CreateControls(dlg) {
    try {
        ; 线程列表
        UI.TH_lv := dlg.Add("ListView", "xm w520 r12 +Grid", ["ID","名称","状态","优先级","并发数"])
        UI.TH_lv.Name := "ThreadList"
        
        ; 操作按钮
        UI.TH_btnAdd := dlg.Add("Button", "xm w90", "新增线程")
        UI.TH_btnAdd.Name := "AddButton"
        
        UI.TH_btnRen := dlg.Add("Button", "x+8 w90", "重命名")
        UI.TH_btnRen.Name := "RenameButton"
        
        UI.TH_btnDel := dlg.Add("Button", "x+8 w90", "删除")
        UI.TH_btnDel.Name := "DeleteButton"
        
        UI.TH_btnSave := dlg.Add("Button", "x+20 w100", "保存")
        UI.TH_btnSave.Name := "SaveButton"
        
        UI.TH_btnClose := dlg.Add("Button", "x+8 w100", "关闭")
        UI.TH_btnClose.Name := "CloseButton"
        
        ; 引用统计区域
        UI.TH_GB_Ref := dlg.Add("GroupBox", "xm y+10 w520 h100", "引用统计")
        UI.TH_lblRef := dlg.Add("Text", "x+12 y+20 w500 h80", "加载中...")
        UI.TH_lblRef.Name := "ReferenceInfo"
        
        ThreadsManager_Log("控件创建完成")
    } catch error {
        ThreadsManager_Log("创建控件失败: " error.message)
    }
}

; 绑定事件
ThreadsManager_BindEvents() {
    try {
        ; 按钮事件
        UI.TH_btnAdd.OnEvent("Click", ThreadsManager_OnAdd)
        UI.TH_btnRen.OnEvent("Click", ThreadsManager_OnRename)
        UI.TH_btnDel.OnEvent("Click", ThreadsManager_OnDelete)
        UI.TH_btnSave.OnEvent("Click", ThreadsManager_OnSave)
        UI.TH_btnClose.OnEvent("Click", ThreadsManager_OnClose)
        
        ; 列表事件
        UI.TH_lv.OnEvent("DoubleClick", ThreadsManager_OnListDoubleClick)
        
        ; 对话框事件
        UI.TH_dlg.OnEvent("Close", ThreadsManager_OnClose)
        UI.TH_dlg.OnEvent("Escape", ThreadsManager_OnClose)
        
        ThreadsManager_Log("事件绑定完成")
    } catch error {
        ThreadsManager_Log("绑定事件失败: " error.message)
    }
}
```

#### 数据初始化

**ThreadsManager_InitializeData()**
```autohotkey
; 初始化线程数据
ThreadsManager_InitializeData() {
    global App
    
    try {
        ; 加载线程数据
        ThreadsManager_LoadThreadData()
        
        ; 刷新列表显示
        ThreadsManager_RefreshList()
        
        ; 更新引用统计
        ThreadsManager_UpdateReferenceStats()
        
        ThreadsManager_Log("线程数据初始化完成")
    } catch error {
        ThreadsManager_Log("初始化数据失败: " error.message)
    }
}

; 加载线程数据
ThreadsManager_LoadThreadData() {
    global App
    
    try {
        ; 获取配置中的线程数据
        if !App.Has("ProfileData") || !App["ProfileData"].Has("Threads") {
            App["ProfileData"].Threads := [ { Id: 1, Name: "默认线程" } ]
            return
        }
        
        threads := App["ProfileData"].Threads
        
        ; 数据验证和修复
        if !IsObject(threads) {
            threads := App["ProfileData"].Threads := [ { Id: 1, Name: "默认线程" } ]
        }
        
        if (threads.Length == 0) {
            threads := App["ProfileData"].Threads := [ { Id: 1, Name: "默认线程" } ]
        }
        
        ; 确保每个线程都有必要字段
        for i, thread in threads {
            if !thread.Has("Id") {
                thread.Id := i + 1
            }
            if !thread.Has("Name") {
                thread.Name := "线程 " thread.Id
            }
            if !thread.Has("Enabled") {
                thread.Enabled := true
            }
            if !thread.Has("Priority") {
                thread.Priority := 0
            }
            if !thread.Has("MaxConcurrent") {
                thread.MaxConcurrent := 1
            }
        }
        
        ThreadsManager_Log("线程数据加载完成: " threads.Length " 个线程")
    } catch error {
        ThreadsManager_Log("加载线程数据失败: " error.message)
    }
}
```

#### 列表显示

**ThreadsManager_RefreshList()**
```autohotkey
; 刷新线程列表
ThreadsManager_RefreshList() {
    try {
        ; 暂停重绘以提高性能
        UI.TH_lv.Opt("-Redraw")
        
        ; 清空列表
        UI.TH_lv.Delete()
        
        ; 获取线程数据
        threads := App["ProfileData"].Threads
        
        ; 添加线程到列表
        for _, thread in threads {
            status := thread.Enabled ? "启用" : "禁用"
            priority := thread.Priority
            concurrent := thread.MaxConcurrent
            
            UI.TH_lv.Add("", thread.Id, thread.Name, status, priority, concurrent)
        }
        
        ; 设置列宽度
        UI.TH_lv.ModifyCol(1, "AutoHdr")  ; ID
        UI.TH_lv.ModifyCol(2, "AutoHdr")  ; 名称
        UI.TH_lv.ModifyCol(3, "AutoHdr")  ; 状态
        UI.TH_lv.ModifyCol(4, "AutoHdr")  ; 优先级
        UI.TH_lv.ModifyCol(5, "AutoHdr")  ; 并发数
        
        ; 恢复重绘
        UI.TH_lv.Opt("+Redraw")
        
        ThreadsManager_Log("线程列表刷新完成")
    } catch error {
        ThreadsManager_Log("刷新列表失败: " error.message)
    }
}
```

#### 引用检查

**ThreadsManager_CheckThreadReferences()**
```autohotkey
; 检查线程引用
ThreadsManager_CheckThreadReferences(threadId) {
    global App
    
    try {
        references := {
            Rules: [],
            Buffs: [],
            TotalReferences: 0
        }
        
        ; 检查规则引用
        if HasProp(App["ProfileData"], "Rules") {
            for _, rule in App["ProfileData"].Rules {
                if (HasProp(rule, "ThreadId") && rule.ThreadId == threadId) {
                    references.Rules.Push({
                        Name: rule.Name,
                        Type: "规则",
                        Id: rule.Id
                    })
                }
            }
        }
        
        ; 检查BUFF引用
        if HasProp(App["ProfileData"], "Buffs") {
            for _, buff in App["ProfileData"].Buffs {
                if (HasProp(buff, "ThreadId") && buff.ThreadId == threadId) {
                    references.Buffs.Push({
                        Name: buff.Name,
                        Type: "BUFF",
                        Id: buff.Id
                    })
                }
            }
        }
        
        ; 计算总引用数
        references.TotalReferences := references.Rules.Length + references.Buffs.Length
        references.LastCheck := A_TickCount
        
        return references
    } catch error {
        ThreadsManager_Log("检查线程引用失败: " error.message)
        return { Rules: [], Buffs: [], TotalReferences: 0 }
    }
}

; 显示引用信息
ThreadsManager_ShowReferenceInfo(threadId) {
    try {
        references := ThreadsManager_CheckThreadReferences(threadId)
        
        infoText := "线程 " threadId " 引用统计:`n"
        infoText .= "规则引用: " references.Rules.Length " 个`n"
        infoText .= "BUFF引用: " references.Buffs.Length " 个`n"
        infoText .= "总引用数: " references.TotalReferences " 个`n"
        
        if (references.TotalReferences > 0) {
            infoText .= "`n被引用的组件:`n"
            
            ; 显示规则引用
            for _, ref in references.Rules {
                infoText .= "  - 规则: " ref.Name "`n"
            }
            
            ; 显示BUFF引用
            for _, ref in references.Buffs {
                infoText .= "  - BUFF: " ref.Name "`n"
            }
        } else {
            infoText .= "`n该线程未被任何组件引用"
        }
        
        ; 更新显示
        if (UI.TH_lblRef) {
            UI.TH_lblRef.Text := infoText
        }
        
        return references
    } catch error {
        ThreadsManager_Log("显示引用信息失败: " error.message)
        return false
    }
}
```

#### 操作处理

**ThreadsManager_OnAdd()**
```autohotkey
; 新增线程
ThreadsManager_OnAdd(*) {
    global App
    
    try {
        ; 显示输入对话框
        name := InputBox("请输入线程名称:", "新增线程", "线程 " (App["ProfileData"].Threads.Length + 1)).Value
        
        if (name == "" || name == "Cancel") {
            return
        }
        
        ; 验证名称
        if !ThreadsManager_ValidateThreadName(name) {
            MsgBox("线程名称无效或已存在")
            return
        }
        
        ; 创建新线程
        newThread := {
            Id: ThreadsManager_GetNextThreadId(),
            Name: name,
            Enabled: true,
            Priority: 0,
            MaxConcurrent: 1,
            Created: A_TickCount,
            Modified: A_TickCount
        }
        
        ; 添加到配置
        App["ProfileData"].Threads.Push(newThread)
        
        ; 刷新显示
        ThreadsManager_RefreshList()
        
        ; 更新引用统计
        ThreadsManager_UpdateReferenceStats()
        
        Notify("线程 '" name "' 创建成功")
        ThreadsManager_Log("新增线程: " name)
    } catch error {
        ThreadsManager_Log("新增线程失败: " error.message)
        MsgBox("新增线程失败: " error.message)
    }
}

; 重命名线程
ThreadsManager_OnRename(*) {
    global App
    
    try {
        ; 获取选中的行
        row := UI.TH_lv.GetNext(0, "Focused")
        if (!row) {
            MsgBox("请选择要重命名的线程")
            return
        }
        
        ; 获取当前信息
        idText := UI.TH_lv.GetText(row, 1)
        nameText := UI.TH_lv.GetText(row, 2)
        threadId := Integer(idText)
        
        ; 显示输入对话框
        newName := InputBox("请输入新的线程名称:", "重命名线程", nameText).Value
        
        if (newName == "" || newName == "Cancel") {
            return
        }
        
        ; 验证名称
        if (!ThreadsManager_ValidateThreadName(newName, threadId)) {
            MsgBox("线程名称无效或已存在")
            return
        }
        
        ; 更新线程名称
        threads := App["ProfileData"].Threads
        for i, thread in threads {
            if (thread.Id == threadId) {
                oldName := thread.Name
                thread.Name := newName
                thread.Modified := A_TickCount
                break
            }
        }
        
        ; 刷新显示
        ThreadsManager_RefreshList()
        
        Notify("线程已从 '" oldName "' 重命名为 '" newName "'")
        ThreadsManager_Log("重命名线程: " oldName " -> " newName)
    } catch error {
        ThreadsManager_Log("重命名线程失败: " error.message)
        MsgBox("重命名线程失败: " error.message)
    }
}

; 删除线程
ThreadsManager_OnDelete(*) {
    global App
    
    try {
        ; 获取选中的行
        row := UI.TH_lv.GetNext(0, "Focused")
        if (!row) {
            MsgBox("请选择要删除的线程")
            return
        }
        
        ; 获取线程信息
        idText := UI.TH_lv.GetText(row, 1)
        nameText := UI.TH_lv.GetText(row, 2)
        threadId := Integer(idText)
        
        ; 检查是否被引用
        references := ThreadsManager_CheckThreadReferences(threadId)
        if (references.TotalReferences > 0) {
            MsgBox("该线程被以下组件引用，无法删除:`n`n" 
                ThreadsManager_FormatReferences(references)
                "`n请先修改相关组件的线程设置。")
            return
        }
        
        ; 确认删除
        if !Confirm("确定要删除线程 '" nameText "' 吗？`n`n此操作不可撤销。") {
            return
        }
        
        ; 检查是否至少保留一个线程
        threads := App["ProfileData"].Threads
        if (threads.Length <= 1) {
            MsgBox("至少需要保留一个线程")
            return
        }
        
        ; 删除线程
        for i, thread in threads {
            if (thread.Id == threadId) {
                threads.RemoveAt(i)
                break
            }
        }
        
        ; 刷新显示
        ThreadsManager_RefreshList()
        ThreadsManager_UpdateReferenceStats()
        
        Notify("线程 '" nameText "' 已删除")
        ThreadsManager_Log("删除线程: " nameText)
    } catch error {
        ThreadsManager_Log("删除线程失败: " error.message)
        MsgBox("删除线程失败: " error.message)
    }
}
```

#### 保存操作

**ThreadsManager_OnSave()**
```autohotkey
; 保存配置
ThreadsManager_OnSave(*) {
    try {
        ; 保存到配置文件
        if (!Storage_SaveProfile(App["ProfileData"])) {
            MsgBox("保存配置文件失败")
            return
        }
        
        ; 重建工作池
        if (!WorkerPool_Rebuild()) {
            MsgBox("重建工作池失败")
            return
        }
        
        ; 更新引用统计
        ThreadsManager_UpdateReferenceStats()
        
        Notify("线程配置已保存并重建进程池")
        ThreadsManager_Log("线程配置保存完成")
    } catch error {
        ThreadsManager_Log("保存配置失败: " error.message)
        MsgBox("保存配置失败: " error.message)
    }
}
```

## 4. 工作池控制器 - WorkerPool.ahk (运行时部分)

### 核心功能

工作池控制器提供运行时的工作进程管理、施法锁系统、技能分发等功能。

**主要特性**:
- **进程管理**: 动态创建和销毁工作进程
- **施法锁**: 避免技能冲突的锁机制
- **技能分发**: 高效的技能执行分发
- **性能监控**: 实时性能数据收集

### 核心函数详解

#### 施法锁系统

**WorkerPool_CastIsLocked()**
```autohotkey
; 检查施法锁状态
WorkerPool_CastIsLocked(threadId) {
    try {
        ; 获取当前活跃的施法锁
        activeLocks := WorkerPool_GetActiveCastLocks()
        
        ; 检查指定线程是否被锁定
        for lockKey, lockInfo in activeLocks {
            if (lockInfo.ThreadId == threadId) {
                remainTime := lockInfo.ExpiredTime - A_TickCount
                
                if (remainTime > 0) {
                    return {
                        Locked: true,
                        LockKey: lockKey,
                        Remain: remainTime,
                        LockInfo: lockInfo
                    }
                } else {
                    ; 清理过期锁
                    WorkerPool_RemoveCastLock(lockKey)
                }
            }
        }
        
        return { Locked: false, Remain: 0 }
    } catch error {
        WP_Log("检查施法锁失败: " error.message)
        return { Locked: false, Remain: 0 }
    }
}

; 获取活跃施法锁
WorkerPool_GetActiveCastLocks() {
    global App
    
    try {
        if !App.Has("CastLocks") {
            App.CastLocks := Map()
            return App.CastLocks
        }
        
        ; 清理过期锁
        WorkerPool_CleanupExpiredCastLocks()
        
        return App.CastLocks
    } catch error {
        WP_Log("获取活跃施法锁失败: " error.message)
        return Map()
    }
}

; 清理过期施法锁
WorkerPool_CleanupExpiredCastLocks() {
    global App
    
    try {
        if !App.Has("CastLocks") {
            return
        }
        
        currentTime := A_TickCount
        expiredKeys := []
        
        ; 查找过期锁
        for lockKey, lockInfo in App.CastLocks {
            if (currentTime >= lockInfo.ExpiredTime) {
                expiredKeys.Push(lockKey)
            }
        }
        
        ; 删除过期锁
        for key in expiredKeys {
            App.CastLocks.Delete(key)
            WP_Log("清理过期施法锁: " key)
        }
        
        if (expiredKeys.Length > 0) {
            WP_Log("清理过期施法锁完成: " expiredKeys.Length " 个")
        }
    } catch error {
        WP_Log("清理过期施法锁失败: " error.message)
    }
}
```

#### 技能发送

**WorkerPool_SendSkillIndex()**
```autohotkey
; 发送技能索引（主入口函数）
WorkerPool_SendSkillIndex(threadId, idx, src := "", holdOverride := -1) {
    global App
    
    try {
        ; 验证参数
        if (idx < 1 || idx > App["ProfileData"].Skills.Length) {
            WP_Log(Format("技能索引无效: {1}", idx))
            return false
        }
        
        skill := App["ProfileData"].Skills[idx]
        
        ; 检查施法锁
        lockStatus := WorkerPool_CastIsLocked(threadId)
        if (lockStatus.Locked) {
            WP_Log(Format("施法锁阻止: 线程={1}, 技能=#{2}, 剩余={3}ms, 来源={4}"
                , threadId, idx, lockStatus.Remain, (src != "" ? src : "?")))
            return false
        }
        
        ; 计算延迟
        delay := WorkerPool_CalculateSendDelay()
        
        ; 确定最终按住时间
        finalHold := WorkerPool_DetermineHoldTime(holdOverride, skill)
        
        ; 执行发送
        return WorkerPool_ExecuteSkillSend(threadId, idx, skill, delay, finalHold, src)
    } catch error {
        WP_Log("发送技能异常: " error.message)
        return false
    }
}

; 计算发送延迟
WorkerPool_CalculateSendDelay() {
    global App
    
    try {
        delay := 0
        
        ; 从配置文件读取默认延迟
        if (HasProp(App, "ProfileData") && App["ProfileData"].Has("SendCooldownMs")) {
            delay := Max(0, Integer(App["ProfileData"].SendCooldownMs))
        }
        
        ; 根据系统负载动态调整
        if (WorkerPool_GetSystemLoad() > 0.8) {
            delay += 10  ; 高负载时增加延迟
        }
        
        return delay
    } catch error {
        WP_Log("计算发送延迟失败: " error.message)
        return 0
    }
}

; 确定按住时间
WorkerPool_DetermineHoldTime(holdOverride, skill) {
    try {
        if (holdOverride >= 0) {
            return Max(0, Integer(holdOverride))
        }
        
        ; 使用技能默认按住时间
        if (skill.Has("HoldTime")) {
            return Max(0, Integer(skill.HoldTime))
        }
        
        ; 使用系统默认时间
        return 100  ; 默认100ms
    } catch error {
        WP_Log("确定按住时间失败: " error.message)
        return 100
    }
}

; 执行技能发送
WorkerPool_ExecuteSkillSend(threadId, idx, skill, delay, holdTime, source) {
    try {
        ; 构建命令
        qkey := '"' WorkerPool_GetSkillKeyString(idx) '"'
        cmd := '"' WorkerPool_GetWorkerHostPath() '" --fire ' . qkey . ' ' . delay . ' ' . holdTime
        
        WP_Log(Format("开始一次性执行: 技能#{1} '{2}' -> 线程{3}, 延迟={4}ms, 按住={5}ms, 来源={6}"
            , idx, skill.Name, threadId, delay, holdTime, source))
        
        ; 创建进程
        processResult := WorkerPool_CreateProcess(cmd)
        
        if (!processResult) {
            WP_Log("创建执行进程失败")
            return false
        }
        
        ; 更新计数器
        WorkerPool_UpdateSkillCounters(idx, source)
        
        ; 更新施法锁
        WorkerPool_UpdateCastLock(threadId, idx, skill)
        
        ; 通知相关引擎
        WorkerPool_NotifySkillExecuted(idx, source)
        
        ; 清理进程句柄
        try {
            DllCall("Kernel32.dll\CloseHandle", "Ptr", processResult.hThread)
            DllCall("Kernel32.dll\CloseHandle", "Ptr", processResult.hProcess)
        } catch {
            ; 忽略清理失败
        }
        
        return true
    } catch error {
        WP_Log("执行技能发送失败: " error.message)
        return false
    }
}

; 获取技能按键字符串
WorkerPool_GetSkillKeyString(idx) {
    global App
    
    try {
        skill := App["ProfileData"].Skills[idx]
        
        ; 优先使用技能定义的按键
        if (skill.Has("Key") && skill.Key != "") {
            return skill.Key
        }
        
        ; 根据索引生成默认按键
        if (idx >= 1 && idx <= 9) {
            return String(idx)
        } else if (idx >= 11 && idx <= 19) {
            return "F" . (idx - 10)
        } else {
            return "F12"  ; 默认功能键
        }
    } catch error {
        WP_Log("获取技能按键字符串失败: " error.message)
        return "F12"
    }
}
```

#### 性能监控

**WorkerPool_GetSystemLoad()**
```autohotkey
; 获取系统负载
WorkerPool_GetSystemLoad() {
    try {
        ; CPU使用率估算
        cpuUsage := WorkerPool_GetCPUUsage()
        
        ; 内存使用率
        memoryUsage := WorkerPool_GetMemoryUsage()
        
        ; 进程队列长度
        queueLength := WorkerPool_GetProcessQueueLength()
        
        ; 计算综合负载
        loadScore := 0
        
        ; CPU负载 (40%权重)
        if (cpuUsage > 0.8) loadScore += 0.32
        else if (cpuUsage > 0.6) loadScore += 0.24
        else if (cpuUsage > 0.4) loadScore += 0.16
        else if (cpuUsage > 0.2) loadScore += 0.08
        
        ; 内存负载 (30%权重)
        if (memoryUsage > 0.8) loadScore += 0.24
        else if (memoryUsage > 0.6) loadScore += 0.18
        else if (memoryUsage > 0.4) loadScore += 0.12
        else if (memoryUsage > 0.2) loadScore += 0.06
        
        ; 队列负载 (30%权重)
        maxQueueLength := 10
        queueRatio := Min(1.0, queueLength / maxQueueLength)
        loadScore += queueRatio * 0.3
        
        return Min(1.0, loadScore)
    } catch error {
        WP_Log("获取系统负载失败: " error.message)
        return 0.5  ; 默认中等负载
    }
}

; 获取CPU使用率
WorkerPool_GetCPUUsage() {
    try {
        ; 简单的CPU使用率估算
        ; 实际项目中可能需要更复杂的实现
        processCount := WorkerPool_GetActiveProcessCount()
        maxProcesses := 4
        
        return Min(1.0, processCount / maxProcesses)
    } catch error {
        WP_Log("获取CPU使用率失败: " error.message)
        return 0.5
    }
}

; 获取内存使用率
WorkerPool_GetMemoryUsage() {
    try {
        ; 获取当前进程内存使用
        processMemory := WorkerPool_GetCurrentProcessMemory()
        maxMemory := 256 * 1024 * 1024  ; 256MB
        
        return Min(1.0, processMemory / maxMemory)
    } catch error {
        WP_Log("获取内存使用率失败: " error.message)
        return 0.3
    }
}
```

## 5. 工具函数库 - Utils.ahk

### 核心功能

工具函数库提供通用的辅助函数，包括消息提示、确认对话框、窗口管理等。

**主要特性**:
- **消息提示**: 统一的用户通知系统
- **确认对话框**: 可配置的确认交互
- **窗口管理**: 窗口激活和状态管理
- **数据处理**: 通用数据处理工具

### 核心函数详解

#### 消息提示系统

**Notify()**
```autohotkey
; 显示通知消息
Notify(message, title := "游戏宏工具", timeout := 3000, icon := "info") {
    try {
        ; 格式化消息
        formattedMessage := Utils_FormatMessage(message)
        
        ; 显示托盘提示
        TrayTip(title, formattedMessage, timeout, icon)
        
        ; 可选：显示主窗口通知
        if (UI.Main && UI.Main.Visible) {
            Utils_ShowMainWindowNotification(formattedMessage, icon)
        }
        
        ; 记录日志
        Utils_Log("通知: " message)
        
        return true
    } catch error {
        ; 通知失败时的备用方案
        try {
            MsgBox(message, title)
        } catch {
            ; 完全失败则输出到控制台
            FileAppend(FormatTime(A_Now, "HH:mm:ss") " [通知] " message "`n", A_Temp "\gamemacro_notifications.log")
        }
        return false
    }
}

; 格式化消息
Utils_FormatMessage(message) {
    try {
        ; 限制消息长度
        if (StrLen(message) > 200) {
            message := SubStr(message, 1, 197) "..."
        }
        
        ; 替换特殊字符
        message := StrReplace(message, "`n", " / ")
        
        ; 确保消息不为空
        if (message == "") {
            message := "无消息"
        }
        
        return message
    } catch error {
        return "消息格式化失败"
    }
}
```

#### 确认对话框

**Confirm()**
```autohotkey
; 显示确认对话框
Confirm(message, title := "确认操作", defaultButton := "OK") {
    try {
        ; 格式化确认消息
        formattedMessage := Utils_FormatMessage(message)
        
        ; 显示MsgBox确认对话框
        result := MsgBox(formattedMessage . "`n`n确定要继续吗？", title, 4 + 32)  ; 4=YESNO, 32=ICONQUESTION
        
        ; 记录确认操作
        Utils_Log("确认对话框: " message " -> " (result = 6 ? "确定" : "取消"))
        
        return (result = 6)  ; 6=IDYES
    } catch error {
        Utils_Log("确认对话框异常: " error.message)
        return false
    }
}

; 显示带详细信息的确认对话框
ConfirmDetailed(message, details, title := "详细确认") {
    try {
        fullMessage := message . "`n`n详细信息:`n" . details
        
        result := MsgBox(fullMessage . "`n`n确定要继续吗？", title, 4 + 32 + 256)  ; 4=YESNO, 32=ICONQUESTION, 256=DEFBUTTON2
        
        Utils_Log("详细确认: " message " -> " (result = 6 ? "确定" : "取消"))
        
        return (result = 6)
    } catch error {
        Utils_Log("详细确认异常: " error.message)
        return false
    }
}
```

#### 窗口管理

**UI_ActivateMain()**
```autohotkey
; 激活主窗口
UI_ActivateMain() {
    try {
        if (UI.Main) {
            ; 恢复窗口显示
            UI.Main.Show()
            UI.Main.Restore()
            UI.Main.Flash()  ; 轻微闪烁提示
            UI.Main.Focus()
            
            Utils_Log("主窗口已激活")
            return true
        } else {
            Utils_Log("主窗口不存在")
            return false
        }
    } catch error {
        Utils_Log("激活主窗口失败: " error.message)
        return false
    }
}

; 最小化到托盘
UI_MinimizeToTray() {
    try {
        if (UI.Main) {
            UI.Main.Hide()
            
            ; 显示托盘提示
            TrayTip("游戏宏工具", "程序已最小化到托盘", 2000, 1)
            
            Utils_Log("程序已最小化到托盘")
            return true
        } else {
            Utils_Log("主窗口不存在，无法最小化")
            return false
        }
    } catch error {
        Utils_Log("最小化到托盘失败: " error.message)
        return false
    }
}

; 检查窗口状态
UI_CheckMainWindowState() {
    try {
        if (!UI.Main) {
            return { Exists: false, Visible: false, Focused: false }
        }
        
        isVisible := UI.Main.Visible
        isFocused := UI.Main.Focused
        
        return {
            Exists: true,
            Visible: isVisible,
            Focused: isFocused,
            Width: UI.Main.Pos.W,
            Height: UI.Main.Pos.H,
            X: UI.Main.Pos.X,
            Y: UI.Main.Pos.Y
        }
    } catch error {
        Utils_Log("检查窗口状态失败: " error.message)
        return { Exists: false, Visible: false, Focused: false }
    }
}
```

#### 数据处理工具

**Utils_ValidateData()**
```autohotkey
; 验证数据结构
Utils_ValidateData(data, requiredFields, dataType := "object") {
    try {
        validationResult := {
            IsValid: true,
            Errors: [],
            Warnings: []
        }
        
        ; 检查数据类型
        if (dataType == "object") {
            if (!IsObject(data)) {
                validationResult.IsValid := false
                validationResult.Errors.Push("数据类型错误：期望对象")
                return validationResult
            }
        } else if (dataType == "array") {
            if (!IsObject(data) || data.Length == "") {
                validationResult.IsValid := false
                validationResult.Errors.Push("数据类型错误：期望数组")
                return validationResult
            }
        }
        
        ; 检查必需字段
        for _, field in requiredFields {
            if (!data.Has(field)) {
                validationResult.IsValid := false
                validationResult.Errors.Push("缺少必需字段: " field)
            }
        }
        
        ; 额外验证（可扩展）
        validationResult := Utils_AdditionalValidation(data, validationResult)
        
        return validationResult
    } catch error {
        return {
            IsValid: false,
            Errors: ["数据验证异常: " error.message],
            Warnings: []
        }
    }
}

; 数据清理和标准化
Utils_CleanData(data, options := {}) {
    try {
        cleanedData := {}
        
        ; 设置默认选项
        defaultOptions := {
            TrimStrings: true,
            RemoveEmpty: true,
            MaxStringLength: 1000,
            ValidateNumbers: true
        }
        
        mergedOptions := Utils_MergeOptions(defaultOptions, options)
        
        ; 递归清理
        cleanedData := Utils_CleanRecursive(data, mergedOptions, 0)
        
        Utils_Log("数据清理完成")
        return cleanedData
    } catch error {
        Utils_Log("数据清理失败: " error.message)
        return {}
    }
}

; 递归数据清理
Utils_CleanRecursive(data, options, depth) {
    try {
        ; 防止无限递归
        if (depth > 10) {
            Utils_Log("警告：数据清理递归深度过大")
            return data
        }
        
        if (IsObject(data)) {
            if (data.Length == "") {
                ; 对象类型
                cleaned := {}
                for key, value in data {
                    cleanedKey := options.TrimStrings ? Trim(String(key)) : String(key)
                    cleanedValue := Utils_CleanRecursive(value, options, depth + 1)
                    
                    ; 移除空值（如果启用）
                    if (options.RemoveEmpty && Utils_IsEmpty(cleanedValue)) {
                        continue
                    }
                    
                    cleaned[cleanedKey] := cleanedValue
                }
                return cleaned
            } else {
                ; 数组类型
                cleaned := []
                for index, value in data {
                    cleanedValue := Utils_CleanRecursive(value, options, depth + 1)
                    
                    if (options.RemoveEmpty && Utils_IsEmpty(cleanedValue)) {
                        continue
                    }
                    
                    cleaned.Push(cleanedValue)
                }
                return cleaned
            }
        } else {
            ; 原始数据类型
            return Utils_CleanPrimitive(data, options)
        }
    } catch error {
        Utils_Log("递归清理异常: " error.message)
        return data
    }
}

; 清理原始数据类型
Utils_CleanPrimitive(value, options) {
    try {
        ; 字符串处理
        if (IsString(value)) {
            if (options.TrimStrings) {
                value := Trim(value)
            }
            
            if (StrLen(value) > options.MaxStringLength) {
                value := SubStr(value, 1, options.MaxStringLength)
            }
        }
        
        ; 数字验证
        if (options.ValidateNumbers && IsNumber(value)) {
            if (value > 2147483647) {  ; 32位整数最大值
                value := 2147483647
            } else if (value < -2147483648) {
                value := -2147483648
            }
        }
        
        return value
    } catch error {
        return value
    }
}
```

## 6. 性能优化策略

### 内存管理优化

**运行时内存优化**
```autohotkey
; 运行时内存优化
Runtime_MemoryOptimization() {
    try {
        ; 强制垃圾回收
        Runtime_ForceGarbageCollection()
        
        ; 清理过期数据
        Runtime_CleanupExpiredData()
        
        ; 压缩数据结构
        Runtime_CompressDataStructures()
        
        ; 清理日志缓存
        Runtime_CleanLogCache()
        
        Utils_Log("运行时内存优化完成")
        return true
    } catch error {
        Utils_Log("运行时内存优化失败: " error.message)
        return false
    }
}

; 强制垃圾回收
Runtime_ForceGarbageCollection() {
    try {
        ; 清理计数器过期数据
        Counters_CleanupMetadata()
        
        ; 清理BUFF元数据
        Runtime_CleanBuffMetadata()
        
        ; 清理工作池历史数据
        WorkerPool_CleanupHistoryData()
        
        ; 触发AutoHotkey垃圾回收
        ; 重新创建大型Map对象
        tempMap := Map()
        for i := 1 to 100 {
            tempMap[i] := "temp_" i
        }
        tempMap := ""
    } catch error {
        Utils_Log("强制垃圾回收失败: " error.message)
    }
}
```

### 执行效率优化

**运行时执行优化**
```autohotkey
; 运行时执行优化
Runtime_ExecutionOptimization() {
    try {
        ; 缓存频繁访问的数据
        Runtime_UpdateDataCache()
        
        ; 优化热键响应
        Runtime_OptimizeHotkeyResponse()
        
        ; 减少UI更新频率
        Runtime_ThrottleUIUpdates()
        
        ; 优化像素检测缓存
        Runtime_OptimizePixelDetection()
        
        Utils_Log("运行时执行优化完成")
        return true
    } catch error {
        Utils_Log("运行时执行优化失败: " error.message)
        return false
    }
}
```

## 总结

运行时组件系统提供了完整的应用程序运行时支撑，具备以下核心能力：

**核心优势**:
- ✅ 轻量级计数器系统，支持原子操作和批量处理
- ✅ 智能BUFF引擎，提供持续时间管理和轮转算法
- ✅ 完善的线程管理系统，支持配置管理和引用检查
- ✅ 高效的工作池控制器，实现进程管理和技能分发
- ✅ 通用工具函数库，简化常用操作实现

**技术特性**:
- **数据管理**: Map数据结构、高效缓存、生命周期管理
- **并发控制**: 施法锁机制、线程协调、状态同步
- **性能优化**: 内存管理、执行效率、缓存策略
- **错误处理**: 异常捕获、恢复机制、日志记录
- **扩展性**: 模块化设计、接口标准化、配置灵活

**应用价值**:
- 为游戏宏工具提供稳定可靠的运行时环境
- 支持高并发的技能执行和状态管理
- 提供完善的监控、日志和调试支持
- 实现高效的内存使用和性能优化
- 支持灵活的扩展和定制需求

**扩展建议**:
- 增加更多运行时监控指标和可视化
- 实现更智能的预测性优化
- 添加分布式运行时支持
- 增加运行时安全沙箱机制
- 实现更完善的数据分析和报告功能