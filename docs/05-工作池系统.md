# 工作池系统 - Worker Pool System Documentation

## 概述

工作池系统是游戏宏工具的核心执行引擎，负责管理后台工作进程和任务调度。系统采用FF-ONLY模式，通过智能工作池管理实现高效的技能执行、状态监控和性能优化。系统包含主控制器WorkerPool.ahk和工作执行器WorkerHost.ahk两个核心模块。

## 系统架构

### 核心组件

1. **WorkerPool.ahk** - 工作池主控制器
2. **WorkerHost.ahk** - 工作执行器
3. **Hotkeys.ahk** - 热键管理模块

### 系统架构图

```
工作池系统
├── WorkerPool (主控制器)
│   ├── 施法锁管理 (Spell Lock System)
│   ├── 线程监控 (Thread Monitoring)
│   ├── 进程创建与管理 (Process Management)
│   ├── WorkerHost定位 (WorkerHost Discovery)
│   ├── 技能发送 (Skill Dispatch)
│   └── FireAndForget机制
├── WorkerHost (执行器)
│   ├── 按键发送 (Key Dispatch)
│   ├── 鼠标操作 (Mouse Operations)
│   ├── 状态反馈 (Status Feedback)
│   ├── WM_COPYDATA通信 (Inter-process Communication)
│   └── 一次性模式 (Fire-and-Forget Mode)
└── Hotkeys (热键管理)
    ├── 热键绑定 (Hotkey Binding)
    ├── 启动热键 (Start/Stop Hotkeys)
    ├── 状态切换 (State Toggle)
    └── 按键穿透 (Key Pass-through)
```

## 1. 工作池主控制器 - WorkerPool.ahk

### 核心功能

WorkerPool是工作池系统的核心控制器，负责管理整个FF-ONLY模式下的工作流程。

**主要特性**:
- **FF-ONLY模式**: 专为游戏定制的纯按键模式
- **施法锁机制**: 基于线程ID的智能锁管理
- **多进程协调**: 多个WorkerHost进程的管理和协调
- **性能监控**: 实时性能数据收集和优化
- **智能调度**: 基于负载的任务分发机制

### 核心数据结构

```autohotkey
; 工作池全局状态
global WorkerPool := {
    Status: "stopped",           // 运行状态
    FFMode: true,               // FF-ONLY模式标志
    Threads: Map(),             // 线程信息映射
    Workers: Map(),             // WorkerHost进程映射
    LockManager: {              // 施法锁管理器
        ActiveLocks: Map(),     // 当前活跃锁
        LockHistory: [],        // 锁历史记录
        MaxLocks: 10           // 最大锁数量
    },
    Performance: {              // 性能统计
        TotalSkills: 0,         // 总执行技能数
        SuccessRate: 0.0,       // 成功率
        AverageLatency: 0,      // 平均延迟
        LastUpdate: 0          // 最后更新时间
    },
    Config: {                   // 工作池配置
        HotkeyDelay: 50,        // 热键延迟
        HoldTime: 100,          // 按住时长
        MaxWorkers: 4,          // 最大Worker数量
        AutoScale: true         // 自动扩缩
    },
    Log: []                     // 日志记录
}

; 线程信息结构
ThreadInfo := {
    ID: 0,                     // 线程ID
    ThreadID: 0,              // 操作系统线程ID
    SkillName: "",            // 当前执行的技能名
    StartTime: 0,             // 开始执行时间
    Status: "idle",           // 执行状态
    LockAcquired: false,      // 是否获得锁
    ProcessID: 0,             // 所属进程ID
    Performance: {            // 性能数据
        ExecutionCount: 0,    // 执行次数
        SuccessCount: 0,      // 成功次数
        LastLatency: 0        // 最后延迟
    }
}

; Worker进程信息
WorkerInfo := {
    PID: 0,                   // 进程ID
    ProcessPath: "",          // 进程路径
    Status: "idle",           // 进程状态
    LastActive: 0,            // 最后活跃时间
    SkillQueue: [],           // 技能队列
    CurrentSkill: "",         // 当前执行技能
    IsAvailable: true,        // 是否可用
    ConnectionStatus: "disconnected"  // 连接状态
}
```

### 核心函数详解

#### 系统初始化

**WorkerPool_Init()**
```autohotkey
; 初始化工作池系统
WorkerPool_Init() {
    global WorkerPool
    
    try {
        ; 设置默认配置
        WorkerPool_SetDefaultConfig()
        
        ; 初始化锁管理器
        WorkerPool_InitLockManager()
        
        ; 扫描WorkerHost文件
        WorkerPool_ScanWorkerHostFiles()
        
        ; 创建初始Worker进程
        WorkerPool_CreateInitialWorkers()
        
        ; 启动性能监控
        WorkerPool_StartPerformanceMonitoring()
        
        WorkerPool_Log("工作池系统初始化完成")
        return true
    } catch error {
        WorkerPool_Log("工作池初始化失败: " error.message)
        return false
    }
}

; 设置默认配置
WorkerPool_SetDefaultConfig() {
    global WorkerPool
    
    ; 从配置文件读取设置
    WorkerPool.Config.HotkeyDelay := AppConfig_GetPerformanceSetting("HotkeyDelay", 50)
    WorkerPool.Config.HoldTime := AppConfig_GetPerformanceSetting("HoldTime", 100)
    WorkerPool.Config.MaxWorkers := AppConfig_GetPerformanceSetting("MaxWorkers", 4)
    WorkerPool.Config.AutoScale := AppConfig_GetPerformanceSetting("AutoScale", true)
    
    WorkerPool_Log("工作池配置加载完成")
}
```

#### 施法锁系统

**WorkerPool_AcquireLock()**
```autohotkey
; 获取施法锁
WorkerPool_AcquireLock(skillName, threadID) {
    global WorkerPool
    
    lockKey := skillName "_" threadID
    
    ; 检查是否已持有该锁
    if WorkerPool.LockManager.ActiveLocks.Has(lockKey) {
        existing := WorkerPool.LockManager.ActiveLocks[lockKey]
        
        ; 检查锁是否仍然有效
        if (A_TickCount - existing.Timestamp < 30000) {  ; 30秒超时
            WorkerPool_Log("锁已存在，技能: " skillName ", 线程: " threadID)
            return false
        } else {
            ; 清理过期锁
            WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
        }
    }
    
    ; 检查锁数量限制
    if (WorkerPool.LockManager.ActiveLocks.Count() >= WorkerPool.LockManager.MaxLocks) {
        WorkerPool_Log("达到最大锁数量限制")
        return false
    }
    
    ; 获取新锁
    lockInfo := {
        SkillName: skillName,
        ThreadID: threadID,
        AcquiredTime: A_TickCount,
        Timestamp: A_TickCount,
        Status: "active"
    }
    
    WorkerPool.LockManager.ActiveLocks[lockKey] := lockInfo
    
    ; 添加到历史记录
    WorkerPool.LockManager.LockHistory.Push({
        Action: "acquire",
        SkillName: skillName,
        ThreadID: threadID,
        Time: A_TickCount
    })
    
    ; 保持历史记录不超过100条
    if (WorkerPool.LockManager.LockHistory.Length > 100) {
        WorkerPool.LockManager.LockHistory.RemoveAt(1)
    }
    
    WorkerPool_Log("获取施法锁成功: " skillName " (线程: " threadID ")")
    return true
}

; 释放施法锁
WorkerPool_ReleaseLock(skillName, threadID) {
    global WorkerPool
    
    lockKey := skillName "_" threadID
    
    if WorkerPool.LockManager.ActiveLocks.Has(lockKey) {
        WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
        
        ; 记录释放事件
        WorkerPool.LockManager.LockHistory.Push({
            Action: "release",
            SkillName: skillName,
            ThreadID: threadID,
            Time: A_TickCount
        })
        
        WorkerPool_Log("释放施法锁: " skillName " (线程: " threadID ")")
        return true
    }
    
    return false
}

; 清理过期锁
WorkerPool_CleanupExpiredLocks() {
    global WorkerPool
    
    currentTime := A_TickCount
    expiredKeys := []
    
    ; 查找过期锁
    for lockKey, lockInfo in WorkerPool.LockManager.ActiveLocks {
        if (currentTime - lockInfo.Timestamp > 60000) {  ; 1分钟超时
            expiredKeys.Push(lockKey)
        }
    }
    
    ; 清理过期锁
    for lockKey in expiredKeys {
        lockInfo := WorkerPool.LockManager.ActiveLocks[lockKey]
        
        WorkerPool_Log("清理过期锁: " lockInfo.SkillName)
        WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
    }
}
```

#### 线程管理

**WorkerPool_RegisterThread()**
```autohotkey
; 注册线程信息
WorkerPool_RegisterThread(threadInfo) {
    global WorkerPool
    
    try {
        ; 创建线程信息对象
        newThread := {
            ID: threadInfo.ID,
            ThreadID: threadInfo.ThreadID,
            SkillName: threadInfo.SkillName,
            StartTime: A_TickCount,
            Status: "registered",
            LockAcquired: false,
            ProcessID: threadInfo.ProcessID,
            Performance: {
                ExecutionCount: 0,
                SuccessCount: 0,
                LastLatency: 0
            }
        }
        
        ; 注册线程
        WorkerPool.Threads.Set(threadInfo.ID, newThread)
        
        WorkerPool_Log("线程注册成功: ID=" threadInfo.ID ", ThreadID=" threadInfo.ThreadID)
        return true
    } catch error {
        WorkerPool_Log("线程注册失败: " error.message)
        return false
    }
}

; 更新线程状态
WorkerPool_UpdateThreadStatus(threadID, newStatus, skillName := "") {
    global WorkerPool
    
    if !WorkerPool.Threads.Has(threadID) {
        WorkerPool_Log("线程不存在: " threadID)
        return false
    }
    
    thread := WorkerPool.Threads[threadID]
    oldStatus := thread.Status
    
    ; 更新状态
    thread.Status := newStatus
    
    if (skillName != "") {
        thread.SkillName := skillName
    }
    
    ; 记录状态变更
    WorkerPool_Log("线程状态更新: " threadID " (" oldStatus " -> " newStatus ")")
    
    return true
}

; 获取可用线程
WorkerPool_GetAvailableThreads() {
    global WorkerPool
    
    availableThreads := []
    
    for threadID, thread in WorkerPool.Threads {
        if (thread.Status == "idle" || thread.Status == "ready") {
            availableThreads.Push(threadID)
        }
    }
    
    return availableThreads
}
```

#### 进程管理

**WorkerPool_CreateWorker()**
```autohotkey
; 创建Worker进程
WorkerPool_CreateWorker(workerPath := "") {
    global WorkerPool
    
    try {
        ; 定位WorkerHost文件
        if (workerPath == "") {
            workerPath := WorkerPool_LocateWorkerHost()
        }
        
        if !FileExist(workerPath) {
            WorkerPool_Log("WorkerHost文件不存在: " workerPath)
            return false
        }
        
        ; 启动Worker进程
        Run(workerPath, A_ScriptDir, "Min", &workerPID)
        
        if (workerPID == 0) {
            WorkerPool_Log("Worker进程启动失败")
            return false
        }
        
        ; 创建Worker信息
        workerInfo := {
            PID: workerPID,
            ProcessPath: workerPath,
            Status: "starting",
            LastActive: A_TickCount,
            SkillQueue: [],
            CurrentSkill: "",
            IsAvailable: false,
            ConnectionStatus: "connecting"
        }
        
        ; 注册Worker
        WorkerPool.Workers.Set(workerPID, workerInfo)
        
        ; 等待Worker就绪
        if WorkerPool_WaitForWorkerReady(workerPID, 5000) {
            WorkerPool_Log("Worker进程创建成功: PID=" workerPID)
            return workerPID
        } else {
            WorkerPool_Log("Worker进程就绪超时: PID=" workerPID)
            WorkerPool_TerminateWorker(workerPID)
            return false
        }
    } catch error {
        WorkerPool_Log("创建Worker进程失败: " error.message)
        return false
    }
}

; 定位WorkerHost文件
WorkerPool_LocateWorkerHost() {
    possiblePaths := [
        A_ScriptDir "\worker\WorkerHost.exe",
        A_ScriptDir "\WorkerHost.exe",
        A_ScriptDir "\worker\WorkerHost.ahk",
        A_ScriptDir "\WorkerHost.ahk"
    ]
    
    for path in possiblePaths {
        if FileExist(path) {
            return path
        }
    }
    
    return ""
}

; 等待Worker就绪
WorkerPool_WaitForWorkerReady(workerPID, timeout := 3000) {
    global WorkerPool
    
    startTime := A_TickCount
    
    while (A_TickCount - startTime < timeout) {
        if WorkerPool.Workers.Has(workerPID) {
            worker := WorkerPool.Workers[workerPID]
            if (worker.ConnectionStatus == "connected") {
                return true
            }
        }
        
        Sleep(100)
    }
    
    return false
}
```

#### 技能发送机制

**WorkerPool_SendSkillIndex()**
```autohotkey
; 发送技能索引到Worker
WorkerPool_SendSkillIndex(skillIndex, threadID, skillName := "") {
    global WorkerPool
    
    try {
        ; 获取可用Worker
        workerPID := WorkerPool_GetAvailableWorker()
        if !workerPID {
            WorkerPool_Log("无可用Worker进程")
            return false
        }
        
        worker := WorkerPool.Workers[workerPID]
        
        ; 发送技能执行指令
        command := {
            Type: "EXECUTE_SKILL",
            SkillIndex: skillIndex,
            ThreadID: threadID,
            SkillName: skillName,
            HotkeyDelay: WorkerPool.Config.HotkeyDelay,
            HoldTime: WorkerPool.Config.HoldTime,
            Timestamp: A_TickCount
        }
        
        ; 通过WM_COPYDATA发送数据
        result := WorkerPool_SendCommandToWorker(workerPID, command)
        
        if result {
            ; 更新Worker状态
            worker.CurrentSkill := skillName
            worker.IsAvailable := false
            worker.LastActive := A_TickCount
            
            ; 更新性能统计
            WorkerPool_UpdatePerformanceStats("skill_sent", skillName)
            
            WorkerPool_Log("技能发送成功: " skillName " -> Worker(" workerPID ")")
            return true
        } else {
            WorkerPool_Log("技能发送失败: " skillName)
            return false
        }
    } catch error {
        WorkerPool_Log("发送技能异常: " error.message)
        return false
    }
}

; 获取可用Worker
WorkerPool_GetAvailableWorker() {
    global WorkerPool
    
    ; 策略：优先使用最少使用的Worker
    minLoad := -1
    selectedWorker := 0
    
    for workerPID, worker in WorkerPool.Workers {
        if (worker.IsAvailable && worker.Status == "idle") {
            queueLoad := worker.SkillQueue.Length
            
            if (minLoad == -1 || queueLoad < minLoad) {
                minLoad := queueLoad
                selectedWorker := workerPID
            }
        }
    }
    
    return selectedWorker
}

; 发送命令到Worker
WorkerPool_SendCommandToWorker(workerPID, command) {
    try {
        ; 序列化命令数据
        commandJSON := JSON.Stringify(command)
        
        ; 通过WM_COPYDATA发送
        result := DllCall("SendMessageW"
            , "Ptr", WorkerPool_GetWorkerHWND(workerPID)
            , "UInt", 0x004A  ; WM_COPYDATA
            , "Ptr", 0        ; wParam
            , "Ptr", WorkerPool_CreateCopyDataStruct(commandJSON)
            , "Ptr")
        
        return (result != 0)
    } catch error {
        WorkerPool_Log("发送命令失败: " error.message)
        return false
    }
}

; 获取Worker窗口句柄
WorkerPool_GetWorkerHWND(workerPID) {
    ; 通过进程ID查找主窗口句柄
    ; 这里需要具体的窗口查找逻辑
    ; 返回Worker进程的主窗口句柄
    return 0  ; 临时返回0，需要实现具体逻辑
}
```

#### FireAndForget机制

**WorkerPool_FireAndForget()**
```autohotkey
; FireAndForget执行模式
WorkerPool_FireAndForget(skillIndex, threadID) {
    global WorkerPool
    
    try {
        ; 异步执行，不等待结果
        ; 适用于不需要确认执行结果的场景
        
        ; 直接发送到最空闲的Worker
        workerPID := WorkerPool_GetBestWorker()
        
        if !workerPID {
            WorkerPool_Log("FireAndForget失败：无可用Worker")
            return false
        }
        
        ; 发送一次性指令
        command := {
            Type: "FIRE_AND_FORGET",
            SkillIndex: skillIndex,
            ThreadID: threadID,
            Delay: WorkerPool.Config.HotkeyDelay,
            HoldTime: WorkerPool.Config.HoldTime
        }
        
        ; 异步发送，不等待响应
        WorkerPool_SendCommandAsync(workerPID, command)
        
        ; 更新统计
        WorkerPool_UpdatePerformanceStats("fire_and_forget", "Skill_" skillIndex)
        
        return true
    } catch error {
        WorkerPool_Log("FireAndForget异常: " error.message)
        return false
    }
}

; 获取最佳Worker
WorkerPool_GetBestWorker() {
    global WorkerPool
    
    bestWorker := 0
    bestScore := -1
    
    for workerPID, worker in WorkerPool.Workers {
        if worker.IsAvailable && worker.Status == "idle" {
            ; 计算Worker评分
            score := WorkerPool_CalculateWorkerScore(worker)
            
            if (score > bestScore) {
                bestScore := score
                bestWorker := workerPID
            }
        }
    }
    
    return bestWorker
}

; 计算Worker评分
WorkerPool_CalculateWorkerScore(worker) {
    baseScore := 100
    
    ; 考虑因素：
    ; - 当前队列长度（越少越好）
    ; - 最后活跃时间（越新越好）
    ; - 历史成功率
    ; - 当前系统负载
    
    queuePenalty := worker.SkillQueue.Length * 10
    timeBonus := (A_TickCount - worker.LastActive) < 1000 ? 10 : 0
    availabilityBonus := worker.IsAvailable ? 20 : 0
    
    return baseScore - queuePenalty + timeBonus + availabilityBonus
}
```

#### 性能监控

**WorkerPool_StartPerformanceMonitoring()**
```autohotkey
; 启动性能监控
WorkerPool_StartPerformanceMonitoring() {
    global WorkerPool
    
    ; 设置定时监控
    SetTimer(WorkerPool_PerformanceMonitor, 1000)  ; 每秒监控一次
    SetTimer(WorkerPool_HealthCheck, 5000)         ; 每5秒健康检查
    
    WorkerPool_Log("性能监控已启动")
}

; 性能监控函数
WorkerPool_PerformanceMonitor() {
    global WorkerPool
    
    try {
        ; 更新性能统计
        WorkerPool_UpdatePerformanceMetrics()
        
        ; 检查Worker健康状态
        WorkerPool_CheckWorkerHealth()
        
        ; 清理过期锁
        WorkerPool_CleanupExpiredLocks()
        
        ; 负载均衡
        WorkerPool_PerformLoadBalancing()
    } catch error {
        WorkerPool_Log("性能监控异常: " error.message)
    }
}

; 更新性能指标
WorkerPool_UpdatePerformanceMetrics() {
    global WorkerPool
    
    ; 计算当前负载
    totalWorkers := WorkerPool.Workers.Count()
    activeWorkers := 0
    totalQueueSize := 0
    
    for workerPID, worker in WorkerPool.Workers {
        if (worker.Status == "active") {
            activeWorkers++
        }
        totalQueueSize += worker.SkillQueue.Length
    }
    
    ; 更新全局性能数据
    WorkerPool.Performance.ActiveWorkers := activeWorkers
    WorkerPool.Performance.TotalWorkers := totalWorkers
    WorkerPool.Performance.QueueSize := totalQueueSize
    WorkerPool.Performance.LoadFactor := totalWorkers > 0 ? activeWorkers / totalWorkers : 0
    WorkerPool.Performance.LastUpdate := A_TickCount
}
```

#### 负载均衡

**WorkerPool_PerformLoadBalancing()**
```autohotkey
; 执行负载均衡
WorkerPool_PerformLoadBalancing() {
    global WorkerPool
    
    ; 检查是否需要扩缩容
    if WorkerPool.Config.AutoScale {
        WorkerPool_AutoScaleWorkers()
    }
    
    ; 重新分配队列
    WorkerPool_RebalanceQueues()
}

; 自动扩缩容
WorkerPool_AutoScaleWorkers() {
    global WorkerPool
    
    currentWorkers := WorkerPool.Workers.Count()
    loadFactor := WorkerPool.Performance.LoadFactor
    
    ; 扩容条件：负载超过80%，且未达到最大Worker数量
    if (loadFactor > 0.8 && currentWorkers < WorkerPool.Config.MaxWorkers) {
        WorkerPool_CreateWorker()
        WorkerPool_Log("负载过高，自动扩容")
    }
    
    ; 缩容条件：负载低于20%，且Worker数量超过2个
    if (loadFactor < 0.2 && currentWorkers > 2) {
        WorkerPool_ReduceWorkers()
        WorkerPool_Log("负载较低，自动缩容")
    }
}
```

## 2. 工作执行器 - WorkerHost.ahk

### 核心功能

WorkerHost是工作执行器，负责接收主控制器指令并执行具体的按键操作。

**主要特性**:
- **一次性模式**: 支持--fire参数的快速执行模式
- **常驻模式**: 基于WM_COPYDATA的持续监听模式
- **多类型按键**: 支持功能键、鼠标键等各种按键类型
- **状态反馈**: 执行结果和状态的实时反馈
- **进程通信**: 高效的进程间通信机制

### 核心数据结构

```autohotkey
; WorkerHost全局状态
global WorkerHost := {
    Mode: "persistent",        ; 运行模式：persistent/fire
    ParentPID: 0,             ; 父进程ID
    Status: "idle",           ; 当前状态
    LastCommand: {},          ; 最后执行的命令
    IsReady: false,           ; 就绪状态
    ExecutionCount: 0,        ; 执行次数
    SuccessCount: 0,          ; 成功次数
    LastExecution: 0,         ; 最后执行时间
    Config: {                 ; 配置
        HotkeyDelay: 50,      ; 热键延迟
        HoldTime: 100,        ; 按住时长
        RetryCount: 3,        ; 重试次数
        Timeout: 5000         ; 超时时间
    }
}

; 命令结构
CommandInfo := {
    Type: "",                 ; 命令类型
    SkillIndex: 0,            ; 技能索引
    ThreadID: 0,              ; 线程ID
    SkillName: "",            ; 技能名称
    HotkeyDelay: 50,          ; 热键延迟
    HoldTime: 100,            ; 按住时长
    Timestamp: 0,             ; 时间戳
    Parameters: {}            ; 额外参数
}

; 按键定义
KeyBinding := {
    VKCode: 0,                ; 虚拟键码
    ScanCode: 0,              ; 扫描码
    KeyName: "",              ; 按键名称
    Type: "normal",           ; 按键类型
    IsExtended: false,        ; 是否扩展键
    MouseButton: ""           ; 鼠标按键
}
```

### 核心函数详解

#### 程序入口

**主函数**
```autohotkey
; WorkerHost主函数
#NoEnv
#SingleInstance Force
#Persistent
#MaxHotkeysPerInterval 99000000
#HotkeyInterval 99000000
#KeyHistory 0
ListLines Off
Process, Priority, , A
SetBatchLines -1
SetKeyDelay -1, -1
SetMouseDelay -1
SetDefaultMouseSpeed 0
SetWinDelay -1
SetControlDelay -1
SendMode Input

; 解析命令行参数
args := {}
for index, param in A_Args {
    if (SubStr(param, 1, 2) == "--") {
        key := SubStr(param, 3)
        value := index + 1 <= A_Args.Length ? A_Args[index + 1] : "true"
        args[key] := value
    }
}

; 初始化WorkerHost
WorkerHost_Init(args)

; 根据模式启动
if (args.Has("fire")) {
    ; 一次性模式
    WorkerHost_FireMode(args)
} else {
    ; 常驻模式
    WorkerHost_PersistentMode()
}
```

#### 系统初始化

**WorkerHost_Init()**
```autohotkey
; 初始化WorkerHost
WorkerHost_Init(args) {
    global WorkerHost
    
    try {
        ; 解析配置参数
        WorkerHost_ParseArgs(args)
        
        ; 创建状态反馈窗口
        WorkerHost_CreateStatusWindow()
        
        ; 初始化按键映射
        WorkerHost_InitKeyBindings()
        
        ; 注册消息处理
        WorkerHost_RegisterMessageHandlers()
        
        WorkerHost.IsReady := true
        WorkerHost_Log("WorkerHost初始化完成")
        
        ; 发送就绪消息
        WorkerHost_SendReadyMessage()
    } catch error {
        WorkerHost_Log("WorkerHost初始化失败: " error.message)
        ExitApp(1)
    }
}

; 解析命令行参数
WorkerHost_ParseArgs(args) {
    global WorkerHost
    
    ; 设置模式
    if args.Has("fire") {
        WorkerHost.Mode := "fire"
    } else {
        WorkerHost.Mode := "persistent"
    }
    
    ; 获取父进程ID
    if args.Has("parent") {
        WorkerHost.ParentPID := Integer(args["parent"])
    }
    
    ; 读取配置参数
    if args.Has("delay") {
        WorkerHost.Config.HotkeyDelay := Integer(args["delay"])
    }
    
    if args.Has("hold") {
        WorkerHost.Config.HoldTime := Integer(args["hold"])
    }
    
    WorkerHost_Log("参数解析完成，模式: " WorkerHost.Mode)
}
```

#### 常驻模式

**WorkerHost_PersistentMode()**
```autohotkey
; 常驻模式主循环
WorkerHost_PersistentMode() {
    global WorkerHost
    
    WorkerHost_Log("启动常驻模式")
    
    ; 启动状态监控
    SetTimer(WorkerHost_StatusMonitor, 1000)
    
    ; 主消息循环
    OnMessage(0x004A, WorkerHost_CopyDataHandler)  ; WM_COPYDATA
    OnExit(WorkerHost_OnExit)
    
    ; 等待消息
    while (WorkerHost.Status != "shutdown") {
        Sleep(100)
        
        ; 检查父进程状态
        if WorkerHost.ParentPID && !ProcessExist(WorkerHost.ParentPID) {
            WorkerHost_Log("父进程已退出，WorkerHost将关闭")
            break
        }
    }
    
    WorkerHost_Log("常驻模式结束")
}

; WM_COPYDATA消息处理
WorkerHost_CopyDataHandler(wParam, lParam) {
    global WorkerHost
    
    try {
        ; 解析COPYDATASTRUCT
        pCopyData := lParam
        cbData := NumGet(pCopyData, 8, "Ptr")  ; cbData字段
        
        ; 读取数据
        dataPtr := NumGet(pCopyData, 16, "Ptr")  ; lpData字段
        data := StrGet(dataPtr, cbData, "UTF-8")
        
        ; 解析JSON命令
        command := JSON.Parse(data)
        
        ; 执行命令
        return WorkerHost_ExecuteCommand(command)
    } catch error {
        WorkerHost_Log("命令处理异常: " error.message)
        return 0
    }
}

; 执行命令
WorkerHost_ExecuteCommand(command) {
    global WorkerHost
    
    try {
        ; 更新状态
        WorkerHost.Status := "executing"
        WorkerHost.LastCommand := command
        
        ; 根据命令类型执行
        result := false
        
        switch command.Type {
            case "EXECUTE_SKILL":
                result := WorkerHost_ExecuteSkill(command)
            case "FIRE_AND_FORGET":
                result := WorkerHost_FireAndForget(command)
            case "PING":
                result := true
            case "GET_STATUS":
                result := WorkerHost_GetStatus()
            default:
                WorkerHost_Log("未知命令类型: " command.Type)
        }
        
        ; 更新状态
        WorkerHost.Status := "idle"
        WorkerHost.LastExecution := A_TickCount
        
        ; 发送执行结果
        WorkerHost_SendResult(command, result)
        
        return result ? 1 : 0
    } catch error {
        WorkerHost.Status := "error"
        WorkerHost_Log("命令执行异常: " error.message)
        WorkerHost_SendError(command, error.message)
        return 0
    }
}
```

#### 一次性模式

**WorkerHost_FireMode()**
```autohotkey
; 一次性模式执行
WorkerHost_FireMode(args) {
    global WorkerHost
    
    try {
        WorkerHost_Log("启动一次性模式")
        
        ; 解析技能索引
        if !args.Has("skill") {
            WorkerHost_Log("缺少技能参数")
            ExitApp(1)
        }
        
        skillIndex := Integer(args["skill"])
        
        ; 执行技能
        result := WorkerHost_ExecuteSkill({
            Type: "EXECUTE_SKILL",
            SkillIndex: skillIndex,
            HotkeyDelay: WorkerHost.Config.HotkeyDelay,
            HoldTime: WorkerHost.Config.HoldTime
        })
        
        ; 输出结果
        if result {
            FileAppend("SUCCESS`n", "*")
            ExitApp(0)
        } else {
            FileAppend("FAILED`n", "*")
            ExitApp(1)
        }
    } catch error {
        WorkerHost_Log("一次性模式异常: " error.message)
        FileAppend("ERROR: " error.message "`n", "*")
        ExitApp(1)
    }
}
```

#### 技能执行

**WorkerHost_ExecuteSkill()**
```autohotkey
; 执行技能
WorkerHost_ExecuteSkill(command) {
    global WorkerHost
    
    try {
        WorkerHost_Log("执行技能: " command.SkillIndex)
        
        ; 获取技能按键绑定
        keyBinding := WorkerHost_GetSkillBinding(command.SkillIndex)
        if !keyBinding {
            WorkerHost_Log("未找到技能绑定: " command.SkillIndex)
            return false
        }
        
        ; 执行按键
        result := WorkerHost_SendKeyPress(keyBinding, command.HotkeyDelay, command.HoldTime)
        
        ; 更新统计
        WorkerHost.ExecutionCount++
        if result {
            WorkerHost.SuccessCount++
        }
        
        WorkerHost_Log("技能执行" (result ? "成功" : "失败") ": " command.SkillIndex)
        return result
    } catch error {
        WorkerHost_Log("技能执行异常: " error.message)
        return false
    }
}

; 发送按键
WorkerHost_SendKeyPress(keyBinding, delay, holdTime) {
    try {
        ; 根据按键类型执行不同的发送逻辑
        if (keyBinding.Type == "mouse") {
            return WorkerHost_SendMousePress(keyBinding, delay, holdTime)
        } else if (keyBinding.Type == "function") {
            return WorkerHost_SendFunctionKey(keyBinding, delay, holdTime)
        } else {
            return WorkerHost_SendNormalKey(keyBinding, delay, holdTime)
        }
    } catch error {
        WorkerHost_Log("按键发送异常: " error.message)
        return false
    }
}

; 发送普通按键
WorkerHost_SendNormalKey(keyBinding, delay, holdTime) {
    try {
        ; 延迟
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; 按下按键
        Send("{" keyBinding.KeyName " down}")
        
        ; 按住时长
        if (holdTime > 0) {
            Sleep(holdTime)
        }
        
        ; 释放按键
        Send("{" keyBinding.KeyName " up}")
        
        return true
    } catch error {
        WorkerHost_Log("普通按键发送失败: " error.message)
        return false
    }
}

; 发送功能键
WorkerHost_SendFunctionKey(keyBinding, delay, holdTime) {
    try {
        ; 功能键的特殊处理
        ; 可能需要使用DllCall直接发送
        
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; 发送功能键
        switch keyBinding.KeyName {
            case "F1":
            case "F2":
            case "F3":
            case "F4":
                DllCall("keybd_event", "UChar", keyBinding.VKCode, "UChar", 0, "UInt", 0, "Ptr", 0)
                Sleep(holdTime)
                DllCall("keybd_event", "UChar", keyBinding.VKCode, "UChar", 0, "UInt", 2, "Ptr", 0)
            default:
                Send("{" keyBinding.KeyName " down}")
                Sleep(holdTime)
                Send("{" keyBinding.KeyName " up}")
        }
        
        return true
    } catch error {
        WorkerHost_Log("功能键发送失败: " error.message)
        return false
    }
}

; 发送鼠标按键
WorkerHost_SendMousePress(keyBinding, delay, holdTime) {
    try {
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; 鼠标按键映射
        switch keyBinding.MouseButton {
            case "LButton":
                Send("{LButton down}")
                Sleep(holdTime)
                Send("{LButton up}")
            case "RButton":
                Send("{RButton down}")
                Sleep(holdTime)
                Send("{RButton up}")
            case "MButton":
                Send("{MButton down}")
                Sleep(holdTime)
                Send("{MButton up}")
            default:
                WorkerHost_Log("未知鼠标按键: " keyBinding.MouseButton)
                return false
        }
        
        return true
    } catch error {
        WorkerHost_Log("鼠标按键发送失败: " error.message)
        return false
    }
}
```

#### 按键映射

**WorkerHost_GetSkillBinding()**
```autohotkey
; 获取技能绑定
WorkerHost_GetSkillBinding(skillIndex) {
    global WorkerHost
    
    ; 从配置文件或内置映射获取
    ; 这里提供一些示例映射
    skillMappings := {
        1: { KeyName: "1", Type: "normal", VKCode: 0x31 },
        2: { KeyName: "2", Type: "normal", VKCode: 0x32 },
        3: { KeyName: "3", Type: "normal", VKCode: 0x33 },
        4: { KeyName: "4", Type: "normal", VKCode: 0x34 },
        5: { KeyName: "5", Type: "normal", VKCode: 0x35 },
        "F1": { KeyName: "F1", Type: "function", VKCode: 0x70 },
        "F2": { KeyName: "F2", Type: "function", VKCode: 0x71 },
        "F3": { KeyName: "F3", Type: "function", VKCode: 0x72 },
        "F4": { KeyName: "F4", Type: "function", VKCode: 0x73 },
        "LButton": { MouseButton: "LButton", Type: "mouse" },
        "RButton": { MouseButton: "RButton", Type: "mouse" }
    }
    
    return skillMappings.Has(skillIndex) ? skillMappings[skillIndex] : false
}
```

#### 进程通信

**WorkerHost_SendResult()**
```autohotkey
; 发送执行结果
WorkerHost_SendResult(command, success) {
    try {
        result := {
            Type: "EXECUTION_RESULT",
            CommandID: command.Timestamp,
            SkillIndex: command.SkillIndex,
            ThreadID: command.ThreadID,
            Success: success,
            ExecutionTime: A_TickCount - command.Timestamp,
            Timestamp: A_TickCount
        }
        
        resultJSON := JSON.Stringify(result)
        
        ; 发送到父进程
        if (WorkerHost.ParentPID) {
            WorkerHost_SendToParent(resultJSON)
        }
    } catch error {
        WorkerHost_Log("发送结果失败: " error.message)
    }
}

; 发送到父进程
WorkerHost_SendToParent(data) {
    try {
        ; 查找父进程窗口
        parentHWND := WorkerHost_FindParentWindow()
        
        if (parentHWND) {
            ; 使用WM_COPYDATA发送
            copyDataStruct := WorkerHost_CreateCopyDataStruct(data)
            DllCall("SendMessageW"
                , "Ptr", parentHWND
                , "UInt", 0x004A  ; WM_COPYDATA
                , "Ptr", 0        ; wParam
                , "Ptr", copyDataStruct
                , "Ptr")
        }
    } catch error {
        WorkerHost_Log("发送到父进程失败: " error.message)
    }
}

; 创建COPYDATASTRUCT
WorkerHost_CreateCopyDataStruct(data) {
    dataSize := (StrLen(data) + 1) * 2  ; UTF-16字符大小
    
    ; 分配内存
    buffer := Buffer(24 + dataSize, 0)  ; COPYDATASTRUCT大小 + 数据
    pBuffer := buffer.Ptr
    
    ; 填充结构
    NumPut("Ptr", 0x004A, pBuffer)                    ; dwData (消息类型)
    NumPut("Int", dataSize, pBuffer + 8)              ; cbData
    NumPut("Ptr", pBuffer + 24, pBuffer + 8)          ; lpData (指向数据区)
    
    ; 写入数据
    StrPut(data, pBuffer + 24, "UTF-16")
    
    return buffer
}
```

#### 状态监控

**WorkerHost_StatusMonitor()**
```autohotkey
; 状态监控
WorkerHost_StatusMonitor() {
    global WorkerHost
    
    try {
        ; 更新状态窗口
        WorkerHost_UpdateStatusWindow()
        
        ; 清理过期数据
        WorkerHost_CleanupOldData()
        
        ; 检查错误状态
        WorkerHost_CheckErrorState()
    } catch error {
        ; 忽略监控错误，避免影响主功能
    }
}

; 更新状态窗口
WorkerHost_UpdateStatusWindow() {
    global WorkerHost
    
    if WorkerHost.StatusWindow {
        ; 更新显示内容
        statusText := "WorkerHost状态:`n"
        statusText .= "模式: " WorkerHost.Mode "`n"
        statusText .= "状态: " WorkerHost.Status "`n"
        statusText .= "执行次数: " WorkerHost.ExecutionCount "`n"
        statusText .= "成功率: " Round(WorkerHost.SuccessCount / Max(1, WorkerHost.ExecutionCount) * 100, 2) "%`n"
        statusText .= "最后执行: " (WorkerHost.LastExecution ? Round((A_TickCount - WorkerHost.LastExecution) / 1000, 1) "秒前" : "无")
        
        ; 更新控件
        GuiControl, WorkerHost.StatusWindow:, WorkerHost.StatusText, %statusText%
    }
}
```

## 3. 热键管理 - Hotkeys.ahk

### 核心功能

Hotkeys模块提供热键绑定和状态切换功能，支持启动/停止热键、按键穿透等特性。

**主要特性**:
- **启动热键**: 绑定开始/停止宏的热键
- **鼠标按键支持**: 自动为鼠标按键添加穿透前缀
- **状态切换**: 切换宏运行状态
- **热键延迟**: 可配置的热键执行延迟
- **按键穿透**: 支持特殊按键的穿透功能

### 核心函数详解

#### 启动热键绑定

**Hotkeys_BindStartHotkey()**
```autohotkey
; 绑定启动热键
Hotkeys_BindStartHotkey(hotkey, callback) {
    try {
        ; 检查是否为鼠标按键
        isMouseKey := Hotkeys_IsMouseKey(hotkey)
        
        modifiedHotkey := hotkey
        
        ; 为鼠标按键添加穿透前缀
        if (isMouseKey) {
            modifiedHotkey := Hotkeys_AddPassThroughPrefix(hotkey)
        }
        
        ; 绑定热键
        try {
            Hotkey(modifiedHotkey, callback, "On")
            
            Hotkeys_Log("热键绑定成功: " hotkey " -> " modifiedHotkey)
            return true
        } catch error {
            Hotkeys_Log("热键绑定失败: " hotkey " - " error.message)
            return false
        }
    } catch error {
        Hotkeys_Log("绑定热键异常: " error.message)
        return false
    }
}

; 检查是否为鼠标按键
Hotkeys_IsMouseKey(hotkey) {
    mouseKeys := ["LButton", "RButton", "MButton", "XButton1", "XButton2"]
    
    for key in mouseKeys {
        if InStr(hotkey, key) {
            return true
        }
    }
    
    return false
}

; 添加穿透前缀
Hotkeys_AddPassThroughPrefix(hotkey) {
    ; AutoHotkey的鼠标按键穿透语法
    ; $ 前缀防止热键递归触发
    return "$" hotkey
}
```

#### 状态切换

**Hotkeys_ToggleRunning()**
```autohotkey
; 切换运行状态
Hotkeys_ToggleRunning() {
    global IsRunning
    
    if (IsRunning) {
        ; 停止运行
        IsRunning := false
        Hotkeys_Log("宏已停止")
        Hotkeys_UpdateTrayStatus("已停止")
    } else {
        ; 开始运行
        IsRunning := true
        Hotkeys_Log("宏已开始")
        Hotkeys_UpdateTrayStatus("运行中")
        
        ; 启动主循环
        SetTimer(MainLoop, 50)
    }
    
    ; 通知UI更新
    if (UI.MainWindow) {
        PostMessage(0x1001, IsRunning ? 1 : 0)  ; 自定义消息
    }
}

; 更新托盘状态
Hotkeys_UpdateTrayStatus(status) {
    try {
        ; 更新托盘菜单文本
        ; 这里需要具体的托盘菜单更新逻辑
        Menu, Tray, Text, 游戏宏工具 [%status%]
    } catch {
        ; 忽略更新失败
    }
}
```

#### 热键执行

**Hotkeys_ExecuteStartCommand()**
```autohotkey
; 执行启动命令
Hotkeys_ExecuteStartCommand() {
    try {
        ; 延迟执行，避免与游戏热键冲突
        Sleep(50)
        
        ; 执行状态切换
        Hotkeys_ToggleRunning()
        
        ; 执行结果反馈
        Hotkeys_FeedbackExecution()
        
    } catch error {
        Hotkeys_Log("启动命令执行异常: " error.message)
    }
}

; 执行结果反馈
Hotkeys_FeedbackExecution() {
    try {
        ; 显示执行反馈（可选）
        ; 发送信号给主程序
        if (WorkerPool.Status == "running") {
            ; 发送切换成功的信号
            ; 这里可以发送特定的信号或消息
        }
    } catch {
        ; 忽略反馈失败
    }
}
```

## 4. 性能优化策略

### 进程池优化

**智能进程管理**:
```autohotkey
; 进程池动态调整
WorkerPool_OptimizeProcessPool() {
    global WorkerPool
    
    ; 根据系统负载调整Worker数量
    systemLoad := WorkerPool_GetSystemLoad()
    optimalWorkers := WorkerPool_CalculateOptimalWorkerCount(systemLoad)
    
    currentWorkers := WorkerPool.Workers.Count()
    
    if (currentWorkers < optimalWorkers) {
        ; 增加Worker
        while (currentWorkers < optimalWorkers) {
            WorkerPool_CreateWorker()
            currentWorkers++
        }
    } else if (currentWorkers > optimalWorkers) {
        ; 减少Worker
        WorkerPool_ReduceExcessWorkers(currentWorkers - optimalWorkers)
    }
}
```

### 内存管理

**内存优化**:
```autohotkey
; 内存清理
WorkerPool_CleanupMemory() {
    ; 清理过期的锁记录
    WorkerPool_CleanupExpiredLocks()
    
    ; 清理历史记录
    if (WorkerPool.LockManager.LockHistory.Length > 100) {
        WorkerPool.LockManager.LockHistory.RemoveAt(1, 50)
    }
    
    ; 强制垃圾回收（如果支持）
    try {
        ; 这里可以添加具体的内存管理调用
    } catch {
        ; 忽略清理异常
    }
}
```

### 延迟优化

**延迟管理**:
```autohotkey
; 智能延迟调整
WorkerPool_AdjustDynamicDelay() {
    global WorkerPool
    
    ; 根据执行成功率调整延迟
    successRate := WorkerPool.Performance.SuccessRate
    
    if (successRate < 0.8) {
        ; 成功率低，增加延迟
        WorkerPool.Config.HotkeyDelay := Min(WorkerPool.Config.HotkeyDelay + 10, 200)
    } else if (successRate > 0.95) {
        ; 成功率高，可以减少延迟
        WorkerPool.Config.HotkeyDelay := Max(WorkerPool.Config.HotkeyDelay - 5, 20)
    }
}
```

## 5. 错误处理与恢复

### 错误处理机制

**全局错误处理**:
```autohotkey
; 工作池错误处理
WorkerPool_HandleError(error, context) {
    global WorkerPool
    
    ; 记录错误
    WorkerPool_Log("错误 [" context "]: " error.message)
    
    ; 分类处理不同类型的错误
    if InStr(error.message, "进程") {
        WorkerPool_HandleProcessError(error)
    } else if InStr(error.message, "内存") {
        WorkerPool_HandleMemoryError(error)
    } else {
        WorkerPool_HandleGeneralError(error)
    }
    
    ; 更新错误统计
    WorkerPool.Performance.ErrorCount++
}

; 进程错误处理
WorkerPool_HandleProcessError(error) {
    ; 重启失败的Worker进程
    ; 重新分配任务
    ; 更新进程健康状态
}

; 内存错误处理  
WorkerPool_HandleMemoryError(error) {
    ; 清理内存缓存
    WorkerPool_CleanupMemory()
    
    ; 减少Worker数量
    if (WorkerPool.Workers.Count() > 2) {
        WorkerPool_ReduceWorkers(1)
    }
}
```

### 自动恢复机制

**恢复策略**:
```autohotkey
; 自动恢复
WorkerPool_AutoRecover() {
    global WorkerPool
    
    try {
        ; 检查并重启崩溃的Worker
        WorkerPool_RestartDeadWorkers()
        
        ; 重新分配未完成的任务
        WorkerPool_ReassignPendingTasks()
        
        ; 清理损坏的状态
        WorkerPool_CleanupCorruptedState()
        
        WorkerPool_Log("自动恢复完成")
        return true
    } catch error {
        WorkerPool_Log("自动恢复失败: " error.message)
        return false
    }
}
```

## 6. 配置管理

### 工作池配置

**配置项说明**:
```autohotkey
; 工作池配置结构
WorkerPool_Config := {
    FFOnlyMode: true,          // FF-ONLY模式
    MaxWorkers: 4,            // 最大Worker数量
    AutoScale: true,          // 自动扩缩容
    HotkeyDelay: 50,          // 热键延迟(毫秒)
    HoldTime: 100,            // 按住时长(毫秒)
    LockTimeout: 30000,       // 锁超时时间
    HealthCheckInterval: 5000, // 健康检查间隔
    PerformanceUpdateInterval: 1000, // 性能更新间隔
    RetryCount: 3,            // 重试次数
    QueueSize: 100,           // 队列大小限制
    LoadThreshold: {          // 负载阈值
        ScaleUp: 0.8,         // 扩容阈值
        ScaleDown: 0.2        // 缩容阈值
    }
}
```

### 配置加载

**配置管理**:
```autohotkey
; 加载工作池配置
WorkerPool_LoadConfig() {
    global WorkerPool
    
    ; 从AppConfig.ini读取
    WorkerPool.Config.MaxWorkers := AppConfig_GetPerformanceSetting("MaxWorkers", 4)
    WorkerPool.Config.HotkeyDelay := AppConfig_GetPerformanceSetting("HotkeyDelay", 50)
    WorkerPool.Config.HoldTime := AppConfig_GetPerformanceSetting("HoldTime", 100)
    WorkerPool.Config.AutoScale := AppConfig_GetPerformanceSetting("AutoScale", true)
    
    ; 验证配置
    WorkerPool_ValidateConfig()
}

; 配置验证
WorkerPool_ValidateConfig() {
    global WorkerPool
    
    ; 确保配置在合理范围内
    WorkerPool.Config.MaxWorkers := Max(1, Min(16, WorkerPool.Config.MaxWorkers))
    WorkerPool.Config.HotkeyDelay := Max(0, Min(1000, WorkerPool.Config.HotkeyDelay))
    WorkerPool.Config.HoldTime := Max(0, Min(5000, WorkerPool.Config.HoldTime))
    
    WorkerPool_Log("配置验证完成")
}
```

## 总结

工作池系统提供了完整的高性能任务执行解决方案，具备以下核心能力：

**核心优势**:
- ✅ FF-ONLY模式专门优化，适合游戏场景
- ✅ 智能施法锁机制，避免技能冲突
- ✅ 多进程并发执行，提升执行效率
- ✅ 完善的性能监控和自动优化
- ✅ 强大的错误处理和自动恢复
- ✅ 灵活的热键管理和按键映射

**技术特性**:
- **进程池管理**: 动态进程创建、销毁和负载均衡
- **通信机制**: 高效的WM_COPYDATA进程间通信
- **锁管理**: 基于线程ID的智能锁机制
- **性能优化**: 实时性能监控和自动调优
- **错误恢复**: 自动错误检测和恢复机制
- **配置灵活**: 丰富的配置选项和实时更新

**应用价值**:
- 为游戏宏工具提供稳定可靠的任务执行引擎
- 支持高并发的技能执行和状态管理
- 提供智能的负载均衡和资源优化
- 实现完善的监控、日志和调试支持
- 支持多种执行模式和灵活的配置管理

**扩展建议**:
- 增加更多通信协议支持（命名管道、共享内存）
- 实现更智能的预测性负载均衡
- 添加GPU加速支持（如适用）
- 实现分布式工作池支持
- 增加更多的性能分析工具和可视化界面