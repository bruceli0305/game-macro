# å·¥ä½œæ± ç³»ç»Ÿ - Worker Pool System Documentation

## æ¦‚è¿°

å·¥ä½œæ± ç³»ç»Ÿæ˜¯Game Macroçš„æ ¸å¿ƒæ‰§è¡Œå¼•æ“ï¼Œè´Ÿè´£ç®¡ç†åå°å·¥ä½œè¿›ç¨‹å’Œä»»åŠ¡è°ƒåº¦ã€‚ç³»ç»Ÿé‡‡ç”¨FF-ONLYæ¨¡å¼ï¼Œé€šè¿‡æ™ºèƒ½å·¥ä½œæ± ç®¡ç†å®ç°é«˜æ•ˆçš„æŠ€èƒ½æ‰§è¡Œã€çŠ¶æ€ç›‘æ§å’Œæ€§èƒ½ä¼˜åŒ–ã€‚ç³»ç»ŸåŒ…å«ä¸»æ§åˆ¶å™¨WorkerPool.ahkå’Œå·¥ä½œæ‰§è¡Œå™¨WorkerHost.ahkä¸¤ä¸ªæ ¸å¿ƒæ¨¡å—ã€‚

## ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶

1. **WorkerPool.ahk** - å·¥ä½œæ± ä¸»æ§åˆ¶å™¨
2. **WorkerHost.ahk** - å·¥ä½œæ‰§è¡Œå™¨
3. **Hotkeys.ahk** - çƒ­é”®ç®¡ç†æ¨¡å—

### ç³»ç»Ÿæ¶æ„å›¾

```
å·¥ä½œæ± ç³»ç»Ÿ
â”œâ”€â”€ WorkerPool (ä¸»æ§åˆ¶å™¨)
â”‚   â”œâ”€â”€ æ–½æ³•é”ç®¡ç† (Spell Lock System)
â”‚   â”œâ”€â”€ çº¿ç¨‹ç›‘æ§ (Thread Monitoring)
â”‚   â”œâ”€â”€ è¿›ç¨‹åˆ›å»ºä¸ç®¡ç† (Process Management)
â”‚   â”œâ”€â”€ WorkerHostå®šä½ (WorkerHost Discovery)
â”‚   â”œâ”€â”€ æŠ€èƒ½å‘é€ (Skill Dispatch)
â”‚   â””â”€â”€ FireAndForgetæœºåˆ¶
â”œâ”€â”€ WorkerHost (æ‰§è¡Œå™¨)
â”‚   â”œâ”€â”€ æŒ‰é”®å‘é€ (Key Dispatch)
â”‚   â”œâ”€â”€ é¼ æ ‡æ“ä½œ (Mouse Operations)
â”‚   â”œâ”€â”€ çŠ¶æ€åé¦ˆ (Status Feedback)
â”‚   â”œâ”€â”€ WM_COPYDATAé€šä¿¡ (Inter-process Communication)
â”‚   â””â”€â”€ ä¸€æ¬¡æ€§æ¨¡å¼ (Fire-and-Forget Mode)
â””â”€â”€ Hotkeys (çƒ­é”®ç®¡ç†)
    â”œâ”€â”€ çƒ­é”®ç»‘å®š (Hotkey Binding)
    â”œâ”€â”€ å¯åŠ¨çƒ­é”® (Start/Stop Hotkeys)
    â”œâ”€â”€ çŠ¶æ€åˆ‡æ¢ (State Toggle)
    â””â”€â”€ æŒ‰é”®ç©¿é€ (Key Pass-through)
```

## 1. å·¥ä½œæ± ä¸»æ§åˆ¶å™¨ - WorkerPool.ahk

### æ ¸å¿ƒåŠŸèƒ½

WorkerPoolæ˜¯å·¥ä½œæ± ç³»ç»Ÿçš„æ ¸å¿ƒæ§åˆ¶å™¨ï¼Œè´Ÿè´£ç®¡ç†æ•´ä¸ªFF-ONLYæ¨¡å¼ä¸‹çš„å·¥ä½œæµç¨‹ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **FF-ONLYæ¨¡å¼**: ä¸“ä¸ºæ¸¸æˆå®šåˆ¶çš„çº¯æŒ‰é”®æ¨¡å¼
- **æ–½æ³•é”æœºåˆ¶**: åŸºäºçº¿ç¨‹IDçš„æ™ºèƒ½é”ç®¡ç†
- **å¤šè¿›ç¨‹åè°ƒ**: å¤šä¸ªWorkerHostè¿›ç¨‹çš„ç®¡ç†å’Œåè°ƒ
- **æ€§èƒ½ç›‘æ§**: å®æ—¶æ€§èƒ½æ•°æ®æ”¶é›†å’Œä¼˜åŒ–
- **æ™ºèƒ½è°ƒåº¦**: åŸºäºè´Ÿè½½çš„ä»»åŠ¡åˆ†å‘æœºåˆ¶

### æ ¸å¿ƒæ•°æ®ç»“æ„

```autohotkey
; å·¥ä½œæ± å…¨å±€çŠ¶æ€
global WorkerPool := {
    Status: "stopped",           // è¿è¡ŒçŠ¶æ€
    FFMode: true,               // FF-ONLYæ¨¡å¼æ ‡å¿—
    Threads: Map(),             // çº¿ç¨‹ä¿¡æ¯æ˜ å°„
    Workers: Map(),             // WorkerHostè¿›ç¨‹æ˜ å°„
    LockManager: {              // æ–½æ³•é”ç®¡ç†å™¨
        ActiveLocks: Map(),     // å½“å‰æ´»è·ƒé”
        LockHistory: [],        // é”å†å²è®°å½•
        MaxLocks: 10           // æœ€å¤§é”æ•°é‡
    },
    Performance: {              // æ€§èƒ½ç»Ÿè®¡
        TotalSkills: 0,         // æ€»æ‰§è¡ŒæŠ€èƒ½æ•°
        SuccessRate: 0.0,       // æˆåŠŸç‡
        AverageLatency: 0,      // å¹³å‡å»¶è¿Ÿ
        LastUpdate: 0          // æœ€åæ›´æ–°æ—¶é—´
    },
    Config: {                   // å·¥ä½œæ± é…ç½®
        HotkeyDelay: 50,        // çƒ­é”®å»¶è¿Ÿ
        HoldTime: 100,          // æŒ‰ä½æ—¶é•¿
        MaxWorkers: 4,          // æœ€å¤§Workeræ•°é‡
        AutoScale: true         // è‡ªåŠ¨æ‰©ç¼©
    },
    Log: []                     // æ—¥å¿—è®°å½•
}

; çº¿ç¨‹ä¿¡æ¯ç»“æ„
ThreadInfo := {
    ID: 0,                     // çº¿ç¨‹ID
    ThreadID: 0,              // æ“ä½œç³»ç»Ÿçº¿ç¨‹ID
    SkillName: "",            // å½“å‰æ‰§è¡Œçš„æŠ€èƒ½å
    StartTime: 0,             // å¼€å§‹æ‰§è¡Œæ—¶é—´
    Status: "idle",           // æ‰§è¡ŒçŠ¶æ€
    LockAcquired: false,      // æ˜¯å¦è·å¾—é”
    ProcessID: 0,             // æ‰€å±è¿›ç¨‹ID
    Performance: {            // æ€§èƒ½æ•°æ®
        ExecutionCount: 0,    // æ‰§è¡Œæ¬¡æ•°
        SuccessCount: 0,      // æˆåŠŸæ¬¡æ•°
        LastLatency: 0        // æœ€åå»¶è¿Ÿ
    }
}

; Workerè¿›ç¨‹ä¿¡æ¯
WorkerInfo := {
    PID: 0,                   // è¿›ç¨‹ID
    ProcessPath: "",          // è¿›ç¨‹è·¯å¾„
    Status: "idle",           // è¿›ç¨‹çŠ¶æ€
    LastActive: 0,            // æœ€åæ´»è·ƒæ—¶é—´
    SkillQueue: [],           // æŠ€èƒ½é˜Ÿåˆ—
    CurrentSkill: "",         // å½“å‰æ‰§è¡ŒæŠ€èƒ½
    IsAvailable: true,        // æ˜¯å¦å¯ç”¨
    ConnectionStatus: "disconnected"  // è¿æ¥çŠ¶æ€
}
```

### æ ¸å¿ƒå‡½æ•°è¯¦è§£

#### ç³»ç»Ÿåˆå§‹åŒ–

**WorkerPool_Init()**
```autohotkey
; åˆå§‹åŒ–å·¥ä½œæ± ç³»ç»Ÿ
WorkerPool_Init() {
    global WorkerPool
    
    try {
        ; è®¾ç½®é»˜è®¤é…ç½®
        WorkerPool_SetDefaultConfig()
        
        ; åˆå§‹åŒ–é”ç®¡ç†å™¨
        WorkerPool_InitLockManager()
        
        ; æ‰«æWorkerHostæ–‡ä»¶
        WorkerPool_ScanWorkerHostFiles()
        
        ; åˆ›å»ºåˆå§‹Workerè¿›ç¨‹
        WorkerPool_CreateInitialWorkers()
        
        ; å¯åŠ¨æ€§èƒ½ç›‘æ§
        WorkerPool_StartPerformanceMonitoring()
        
        WorkerPool_Log("å·¥ä½œæ± ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
        return true
    } catch error {
        WorkerPool_Log("å·¥ä½œæ± åˆå§‹åŒ–å¤±è´¥: " error.message)
        return false
    }
}

; è®¾ç½®é»˜è®¤é…ç½®
WorkerPool_SetDefaultConfig() {
    global WorkerPool
    
    ; ä»é…ç½®æ–‡ä»¶è¯»å–è®¾ç½®
    WorkerPool.Config.HotkeyDelay := AppConfig_GetPerformanceSetting("HotkeyDelay", 50)
    WorkerPool.Config.HoldTime := AppConfig_GetPerformanceSetting("HoldTime", 100)
    WorkerPool.Config.MaxWorkers := AppConfig_GetPerformanceSetting("MaxWorkers", 4)
    WorkerPool.Config.AutoScale := AppConfig_GetPerformanceSetting("AutoScale", true)
    
    WorkerPool_Log("å·¥ä½œæ± é…ç½®åŠ è½½å®Œæˆ")
}
```

#### æ–½æ³•é”ç³»ç»Ÿ

**WorkerPool_AcquireLock()**
```autohotkey
; è·å–æ–½æ³•é”
WorkerPool_AcquireLock(skillName, threadID) {
    global WorkerPool
    
    lockKey := skillName "_" threadID
    
    ; æ£€æŸ¥æ˜¯å¦å·²æŒæœ‰è¯¥é”
    if WorkerPool.LockManager.ActiveLocks.Has(lockKey) {
        existing := WorkerPool.LockManager.ActiveLocks[lockKey]
        
        ; æ£€æŸ¥é”æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
        if (A_TickCount - existing.Timestamp < 30000) {  ; 30ç§’è¶…æ—¶
            WorkerPool_Log("é”å·²å­˜åœ¨ï¼ŒæŠ€èƒ½: " skillName ", çº¿ç¨‹: " threadID)
            return false
        } else {
            ; æ¸…ç†è¿‡æœŸé”
            WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
        }
    }
    
    ; æ£€æŸ¥é”æ•°é‡é™åˆ¶
    if (WorkerPool.LockManager.ActiveLocks.Count() >= WorkerPool.LockManager.MaxLocks) {
        WorkerPool_Log("è¾¾åˆ°æœ€å¤§é”æ•°é‡é™åˆ¶")
        return false
    }
    
    ; è·å–æ–°é”
    lockInfo := {
        SkillName: skillName,
        ThreadID: threadID,
        AcquiredTime: A_TickCount,
        Timestamp: A_TickCount,
        Status: "active"
    }
    
    WorkerPool.LockManager.ActiveLocks[lockKey] := lockInfo
    
    ; æ·»åŠ åˆ°å†å²è®°å½•
    WorkerPool.LockManager.LockHistory.Push({
        Action: "acquire",
        SkillName: skillName,
        ThreadID: threadID,
        Time: A_TickCount
    })
    
    ; ä¿æŒå†å²è®°å½•ä¸è¶…è¿‡100æ¡
    if (WorkerPool.LockManager.LockHistory.Length > 100) {
        WorkerPool.LockManager.LockHistory.RemoveAt(1)
    }
    
    WorkerPool_Log("è·å–æ–½æ³•é”æˆåŠŸ: " skillName " (çº¿ç¨‹: " threadID ")")
    return true
}

; é‡Šæ”¾æ–½æ³•é”
WorkerPool_ReleaseLock(skillName, threadID) {
    global WorkerPool
    
    lockKey := skillName "_" threadID
    
    if WorkerPool.LockManager.ActiveLocks.Has(lockKey) {
        WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
        
        ; è®°å½•é‡Šæ”¾äº‹ä»¶
        WorkerPool.LockManager.LockHistory.Push({
            Action: "release",
            SkillName: skillName,
            ThreadID: threadID,
            Time: A_TickCount
        })
        
        WorkerPool_Log("é‡Šæ”¾æ–½æ³•é”: " skillName " (çº¿ç¨‹: " threadID ")")
        return true
    }
    
    return false
}

; æ¸…ç†è¿‡æœŸé”
WorkerPool_CleanupExpiredLocks() {
    global WorkerPool
    
    currentTime := A_TickCount
    expiredKeys := []
    
    ; æŸ¥æ‰¾è¿‡æœŸé”
    for lockKey, lockInfo in WorkerPool.LockManager.ActiveLocks {
        if (currentTime - lockInfo.Timestamp > 60000) {  ; 1åˆ†é’Ÿè¶…æ—¶
            expiredKeys.Push(lockKey)
        }
    }
    
    ; æ¸…ç†è¿‡æœŸé”
    for lockKey in expiredKeys {
        lockInfo := WorkerPool.LockManager.ActiveLocks[lockKey]
        
        WorkerPool_Log("æ¸…ç†è¿‡æœŸé”: " lockInfo.SkillName)
        WorkerPool.LockManager.ActiveLocks.Delete(lockKey)
    }
}
```

#### çº¿ç¨‹ç®¡ç†

**WorkerPool_RegisterThread()**
```autohotkey
; æ³¨å†Œçº¿ç¨‹ä¿¡æ¯
WorkerPool_RegisterThread(threadInfo) {
    global WorkerPool
    
    try {
        ; åˆ›å»ºçº¿ç¨‹ä¿¡æ¯å¯¹è±¡
        newThread := {
            ID: threadInfo.ID,
            ThreadID: threadInfo.ThreadID,
            SkillName: threadInfo.SkillName,
            StartTime: A_TickCount,
            Status: "registered",
            LockAcquired: false,
            ProcessID: threadInfo.ProcessID,
            Performance: {
                ExecutionCount: 0,
                SuccessCount: 0,
                LastLatency: 0
            }
        }
        
        ; æ³¨å†Œçº¿ç¨‹
        WorkerPool.Threads.Set(threadInfo.ID, newThread)
        
        WorkerPool_Log("çº¿ç¨‹æ³¨å†ŒæˆåŠŸ: ID=" threadInfo.ID ", ThreadID=" threadInfo.ThreadID)
        return true
    } catch error {
        WorkerPool_Log("çº¿ç¨‹æ³¨å†Œå¤±è´¥: " error.message)
        return false
    }
}

; æ›´æ–°çº¿ç¨‹çŠ¶æ€
WorkerPool_UpdateThreadStatus(threadID, newStatus, skillName := "") {
    global WorkerPool
    
    if !WorkerPool.Threads.Has(threadID) {
        WorkerPool_Log("çº¿ç¨‹ä¸å­˜åœ¨: " threadID)
        return false
    }
    
    thread := WorkerPool.Threads[threadID]
    oldStatus := thread.Status
    
    ; æ›´æ–°çŠ¶æ€
    thread.Status := newStatus
    
    if (skillName != "") {
        thread.SkillName := skillName
    }
    
    ; è®°å½•çŠ¶æ€å˜æ›´
    WorkerPool_Log("çº¿ç¨‹çŠ¶æ€æ›´æ–°: " threadID " (" oldStatus " -> " newStatus ")")
    
    return true
}

; è·å–å¯ç”¨çº¿ç¨‹
WorkerPool_GetAvailableThreads() {
    global WorkerPool
    
    availableThreads := []
    
    for threadID, thread in WorkerPool.Threads {
        if (thread.Status == "idle" || thread.Status == "ready") {
            availableThreads.Push(threadID)
        }
    }
    
    return availableThreads
}
```

#### è¿›ç¨‹ç®¡ç†

**WorkerPool_CreateWorker()**
```autohotkey
; åˆ›å»ºWorkerè¿›ç¨‹
WorkerPool_CreateWorker(workerPath := "") {
    global WorkerPool
    
    try {
        ; å®šä½WorkerHostæ–‡ä»¶
        if (workerPath == "") {
            workerPath := WorkerPool_LocateWorkerHost()
        }
        
        if !FileExist(workerPath) {
            WorkerPool_Log("WorkerHostæ–‡ä»¶ä¸å­˜åœ¨: " workerPath)
            return false
        }
        
        ; å¯åŠ¨Workerè¿›ç¨‹
        Run(workerPath, A_ScriptDir, "Min", &workerPID)
        
        if (workerPID == 0) {
            WorkerPool_Log("Workerè¿›ç¨‹å¯åŠ¨å¤±è´¥")
            return false
        }
        
        ; åˆ›å»ºWorkerä¿¡æ¯
        workerInfo := {
            PID: workerPID,
            ProcessPath: workerPath,
            Status: "starting",
            LastActive: A_TickCount,
            SkillQueue: [],
            CurrentSkill: "",
            IsAvailable: false,
            ConnectionStatus: "connecting"
        }
        
        ; æ³¨å†ŒWorker
        WorkerPool.Workers.Set(workerPID, workerInfo)
        
        ; ç­‰å¾…Workerå°±ç»ª
        if WorkerPool_WaitForWorkerReady(workerPID, 5000) {
            WorkerPool_Log("Workerè¿›ç¨‹åˆ›å»ºæˆåŠŸ: PID=" workerPID)
            return workerPID
        } else {
            WorkerPool_Log("Workerè¿›ç¨‹å°±ç»ªè¶…æ—¶: PID=" workerPID)
            WorkerPool_TerminateWorker(workerPID)
            return false
        }
    } catch error {
        WorkerPool_Log("åˆ›å»ºWorkerè¿›ç¨‹å¤±è´¥: " error.message)
        return false
    }
}

; å®šä½WorkerHostæ–‡ä»¶
WorkerPool_LocateWorkerHost() {
    possiblePaths := [
        A_ScriptDir "\worker\WorkerHost.exe",
        A_ScriptDir "\WorkerHost.exe",
        A_ScriptDir "\worker\WorkerHost.ahk",
        A_ScriptDir "\WorkerHost.ahk"
    ]
    
    for path in possiblePaths {
        if FileExist(path) {
            return path
        }
    }
    
    return ""
}

; ç­‰å¾…Workerå°±ç»ª
WorkerPool_WaitForWorkerReady(workerPID, timeout := 3000) {
    global WorkerPool
    
    startTime := A_TickCount
    
    while (A_TickCount - startTime < timeout) {
        if WorkerPool.Workers.Has(workerPID) {
            worker := WorkerPool.Workers[workerPID]
            if (worker.ConnectionStatus == "connected") {
                return true
            }
        }
        
        Sleep(100)
    }
    
    return false
}
```

#### æŠ€èƒ½å‘é€æœºåˆ¶

**WorkerPool_SendSkillIndex()**
```autohotkey
; å‘é€æŠ€èƒ½ç´¢å¼•åˆ°Worker
WorkerPool_SendSkillIndex(skillIndex, threadID, skillName := "") {
    global WorkerPool
    
    try {
        ; è·å–å¯ç”¨Worker
        workerPID := WorkerPool_GetAvailableWorker()
        if !workerPID {
            WorkerPool_Log("æ— å¯ç”¨Workerè¿›ç¨‹")
            return false
        }
        
        worker := WorkerPool.Workers[workerPID]
        
        ; å‘é€æŠ€èƒ½æ‰§è¡ŒæŒ‡ä»¤
        command := {
            Type: "EXECUTE_SKILL",
            SkillIndex: skillIndex,
            ThreadID: threadID,
            SkillName: skillName,
            HotkeyDelay: WorkerPool.Config.HotkeyDelay,
            HoldTime: WorkerPool.Config.HoldTime,
            Timestamp: A_TickCount
        }
        
        ; é€šè¿‡WM_COPYDATAå‘é€æ•°æ®
        result := WorkerPool_SendCommandToWorker(workerPID, command)
        
        if result {
            ; æ›´æ–°WorkerçŠ¶æ€
            worker.CurrentSkill := skillName
            worker.IsAvailable := false
            worker.LastActive := A_TickCount
            
            ; æ›´æ–°æ€§èƒ½ç»Ÿè®¡
            WorkerPool_UpdatePerformanceStats("skill_sent", skillName)
            
            WorkerPool_Log("æŠ€èƒ½å‘é€æˆåŠŸ: " skillName " -> Worker(" workerPID ")")
            return true
        } else {
            WorkerPool_Log("æŠ€èƒ½å‘é€å¤±è´¥: " skillName)
            return false
        }
    } catch error {
        WorkerPool_Log("å‘é€æŠ€èƒ½å¼‚å¸¸: " error.message)
        return false
    }
}

; è·å–å¯ç”¨Worker
WorkerPool_GetAvailableWorker() {
    global WorkerPool
    
    ; ç­–ç•¥ï¼šä¼˜å…ˆä½¿ç”¨æœ€å°‘ä½¿ç”¨çš„Worker
    minLoad := -1
    selectedWorker := 0
    
    for workerPID, worker in WorkerPool.Workers {
        if (worker.IsAvailable && worker.Status == "idle") {
            queueLoad := worker.SkillQueue.Length
            
            if (minLoad == -1 || queueLoad < minLoad) {
                minLoad := queueLoad
                selectedWorker := workerPID
            }
        }
    }
    
    return selectedWorker
}

; å‘é€å‘½ä»¤åˆ°Worker
WorkerPool_SendCommandToWorker(workerPID, command) {
    try {
        ; åºåˆ—åŒ–å‘½ä»¤æ•°æ®
        commandJSON := JSON.Stringify(command)
        
        ; é€šè¿‡WM_COPYDATAå‘é€
        result := DllCall("SendMessageW"
            , "Ptr", WorkerPool_GetWorkerHWND(workerPID)
            , "UInt", 0x004A  ; WM_COPYDATA
            , "Ptr", 0        ; wParam
            , "Ptr", WorkerPool_CreateCopyDataStruct(commandJSON)
            , "Ptr")
        
        return (result != 0)
    } catch error {
        WorkerPool_Log("å‘é€å‘½ä»¤å¤±è´¥: " error.message)
        return false
    }
}

; è·å–Workerçª—å£å¥æŸ„
WorkerPool_GetWorkerHWND(workerPID) {
    ; é€šè¿‡è¿›ç¨‹IDæŸ¥æ‰¾ä¸»çª—å£å¥æŸ„
    ; è¿™é‡Œéœ€è¦å…·ä½“çš„çª—å£æŸ¥æ‰¾é€»è¾‘
    ; è¿”å›Workerè¿›ç¨‹çš„ä¸»çª—å£å¥æŸ„
    return 0  ; ä¸´æ—¶è¿”å›0ï¼Œéœ€è¦å®ç°å…·ä½“é€»è¾‘
}
```

#### FireAndForgetæœºåˆ¶

**WorkerPool_FireAndForget()**
```autohotkey
; FireAndForgetæ‰§è¡Œæ¨¡å¼
WorkerPool_FireAndForget(skillIndex, threadID) {
    global WorkerPool
    
    try {
        ; å¼‚æ­¥æ‰§è¡Œï¼Œä¸ç­‰å¾…ç»“æœ
        ; é€‚ç”¨äºä¸éœ€è¦ç¡®è®¤æ‰§è¡Œç»“æœçš„åœºæ™¯
        
        ; ç›´æ¥å‘é€åˆ°æœ€ç©ºé—²çš„Worker
        workerPID := WorkerPool_GetBestWorker()
        
        if !workerPID {
            WorkerPool_Log("FireAndForgetå¤±è´¥ï¼šæ— å¯ç”¨Worker")
            return false
        }
        
        ; å‘é€ä¸€æ¬¡æ€§æŒ‡ä»¤
        command := {
            Type: "FIRE_AND_FORGET",
            SkillIndex: skillIndex,
            ThreadID: threadID,
            Delay: WorkerPool.Config.HotkeyDelay,
            HoldTime: WorkerPool.Config.HoldTime
        }
        
        ; å¼‚æ­¥å‘é€ï¼Œä¸ç­‰å¾…å“åº”
        WorkerPool_SendCommandAsync(workerPID, command)
        
        ; æ›´æ–°ç»Ÿè®¡
        WorkerPool_UpdatePerformanceStats("fire_and_forget", "Skill_" skillIndex)
        
        return true
    } catch error {
        WorkerPool_Log("FireAndForgetå¼‚å¸¸: " error.message)
        return false
    }
}

; è·å–æœ€ä½³Worker
WorkerPool_GetBestWorker() {
    global WorkerPool
    
    bestWorker := 0
    bestScore := -1
    
    for workerPID, worker in WorkerPool.Workers {
        if worker.IsAvailable && worker.Status == "idle" {
            ; è®¡ç®—Workerè¯„åˆ†
            score := WorkerPool_CalculateWorkerScore(worker)
            
            if (score > bestScore) {
                bestScore := score
                bestWorker := workerPID
            }
        }
    }
    
    return bestWorker
}

; è®¡ç®—Workerè¯„åˆ†
WorkerPool_CalculateWorkerScore(worker) {
    baseScore := 100
    
    ; è€ƒè™‘å› ç´ ï¼š
    ; - å½“å‰é˜Ÿåˆ—é•¿åº¦ï¼ˆè¶Šå°‘è¶Šå¥½ï¼‰
    ; - æœ€åæ´»è·ƒæ—¶é—´ï¼ˆè¶Šæ–°è¶Šå¥½ï¼‰
    ; - å†å²æˆåŠŸç‡
    ; - å½“å‰ç³»ç»Ÿè´Ÿè½½
    
    queuePenalty := worker.SkillQueue.Length * 10
    timeBonus := (A_TickCount - worker.LastActive) < 1000 ? 10 : 0
    availabilityBonus := worker.IsAvailable ? 20 : 0
    
    return baseScore - queuePenalty + timeBonus + availabilityBonus
}
```

#### æ€§èƒ½ç›‘æ§

**WorkerPool_StartPerformanceMonitoring()**
```autohotkey
; å¯åŠ¨æ€§èƒ½ç›‘æ§
WorkerPool_StartPerformanceMonitoring() {
    global WorkerPool
    
    ; è®¾ç½®å®šæ—¶ç›‘æ§
    SetTimer(WorkerPool_PerformanceMonitor, 1000)  ; æ¯ç§’ç›‘æ§ä¸€æ¬¡
    SetTimer(WorkerPool_HealthCheck, 5000)         ; æ¯5ç§’å¥åº·æ£€æŸ¥
    
    WorkerPool_Log("æ€§èƒ½ç›‘æ§å·²å¯åŠ¨")
}

; æ€§èƒ½ç›‘æ§å‡½æ•°
WorkerPool_PerformanceMonitor() {
    global WorkerPool
    
    try {
        ; æ›´æ–°æ€§èƒ½ç»Ÿè®¡
        WorkerPool_UpdatePerformanceMetrics()
        
        ; æ£€æŸ¥Workerå¥åº·çŠ¶æ€
        WorkerPool_CheckWorkerHealth()
        
        ; æ¸…ç†è¿‡æœŸé”
        WorkerPool_CleanupExpiredLocks()
        
        ; è´Ÿè½½å‡è¡¡
        WorkerPool_PerformLoadBalancing()
    } catch error {
        WorkerPool_Log("æ€§èƒ½ç›‘æ§å¼‚å¸¸: " error.message)
    }
}

; æ›´æ–°æ€§èƒ½æŒ‡æ ‡
WorkerPool_UpdatePerformanceMetrics() {
    global WorkerPool
    
    ; è®¡ç®—å½“å‰è´Ÿè½½
    totalWorkers := WorkerPool.Workers.Count()
    activeWorkers := 0
    totalQueueSize := 0
    
    for workerPID, worker in WorkerPool.Workers {
        if (worker.Status == "active") {
            activeWorkers++
        }
        totalQueueSize += worker.SkillQueue.Length
    }
    
    ; æ›´æ–°å…¨å±€æ€§èƒ½æ•°æ®
    WorkerPool.Performance.ActiveWorkers := activeWorkers
    WorkerPool.Performance.TotalWorkers := totalWorkers
    WorkerPool.Performance.QueueSize := totalQueueSize
    WorkerPool.Performance.LoadFactor := totalWorkers > 0 ? activeWorkers / totalWorkers : 0
    WorkerPool.Performance.LastUpdate := A_TickCount
}
```

#### è´Ÿè½½å‡è¡¡

**WorkerPool_PerformLoadBalancing()**
```autohotkey
; æ‰§è¡Œè´Ÿè½½å‡è¡¡
WorkerPool_PerformLoadBalancing() {
    global WorkerPool
    
    ; æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©ç¼©å®¹
    if WorkerPool.Config.AutoScale {
        WorkerPool_AutoScaleWorkers()
    }
    
    ; é‡æ–°åˆ†é…é˜Ÿåˆ—
    WorkerPool_RebalanceQueues()
}

; è‡ªåŠ¨æ‰©ç¼©å®¹
WorkerPool_AutoScaleWorkers() {
    global WorkerPool
    
    currentWorkers := WorkerPool.Workers.Count()
    loadFactor := WorkerPool.Performance.LoadFactor
    
    ; æ‰©å®¹æ¡ä»¶ï¼šè´Ÿè½½è¶…è¿‡80%ï¼Œä¸”æœªè¾¾åˆ°æœ€å¤§Workeræ•°é‡
    if (loadFactor > 0.8 && currentWorkers < WorkerPool.Config.MaxWorkers) {
        WorkerPool_CreateWorker()
        WorkerPool_Log("è´Ÿè½½è¿‡é«˜ï¼Œè‡ªåŠ¨æ‰©å®¹")
    }
    
    ; ç¼©å®¹æ¡ä»¶ï¼šè´Ÿè½½ä½äº20%ï¼Œä¸”Workeræ•°é‡è¶…è¿‡2ä¸ª
    if (loadFactor < 0.2 && currentWorkers > 2) {
        WorkerPool_ReduceWorkers()
        WorkerPool_Log("è´Ÿè½½è¾ƒä½ï¼Œè‡ªåŠ¨ç¼©å®¹")
    }
}
```

## 2. å·¥ä½œæ‰§è¡Œå™¨ - WorkerHost.ahk

### æ ¸å¿ƒåŠŸèƒ½

WorkerHostæ˜¯å·¥ä½œæ‰§è¡Œå™¨ï¼Œè´Ÿè´£æ¥æ”¶ä¸»æ§åˆ¶å™¨æŒ‡ä»¤å¹¶æ‰§è¡Œå…·ä½“çš„æŒ‰é”®æ“ä½œã€‚

**ä¸»è¦ç‰¹æ€§**:
- **ä¸€æ¬¡æ€§æ¨¡å¼**: æ”¯æŒ--fireå‚æ•°çš„å¿«é€Ÿæ‰§è¡Œæ¨¡å¼
- **å¸¸é©»æ¨¡å¼**: åŸºäºWM_COPYDATAçš„æŒç»­ç›‘å¬æ¨¡å¼
- **å¤šç±»å‹æŒ‰é”®**: æ”¯æŒåŠŸèƒ½é”®ã€é¼ æ ‡é”®ç­‰å„ç§æŒ‰é”®ç±»å‹
- **çŠ¶æ€åé¦ˆ**: æ‰§è¡Œç»“æœå’ŒçŠ¶æ€çš„å®æ—¶åé¦ˆ
- **è¿›ç¨‹é€šä¿¡**: é«˜æ•ˆçš„è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶

### æ ¸å¿ƒæ•°æ®ç»“æ„

```autohotkey
; WorkerHostå…¨å±€çŠ¶æ€
global WorkerHost := {
    Mode: "persistent",        ; è¿è¡Œæ¨¡å¼ï¼špersistent/fire
    ParentPID: 0,             ; çˆ¶è¿›ç¨‹ID
    Status: "idle",           ; å½“å‰çŠ¶æ€
    LastCommand: {},          ; æœ€åæ‰§è¡Œçš„å‘½ä»¤
    IsReady: false,           ; å°±ç»ªçŠ¶æ€
    ExecutionCount: 0,        ; æ‰§è¡Œæ¬¡æ•°
    SuccessCount: 0,          ; æˆåŠŸæ¬¡æ•°
    LastExecution: 0,         ; æœ€åæ‰§è¡Œæ—¶é—´
    Config: {                 ; é…ç½®
        HotkeyDelay: 50,      ; çƒ­é”®å»¶è¿Ÿ
        HoldTime: 100,        ; æŒ‰ä½æ—¶é•¿
        RetryCount: 3,        ; é‡è¯•æ¬¡æ•°
        Timeout: 5000         ; è¶…æ—¶æ—¶é—´
    }
}

; å‘½ä»¤ç»“æ„
CommandInfo := {
    Type: "",                 ; å‘½ä»¤ç±»å‹
    SkillIndex: 0,            ; æŠ€èƒ½ç´¢å¼•
    ThreadID: 0,              ; çº¿ç¨‹ID
    SkillName: "",            ; æŠ€èƒ½åç§°
    HotkeyDelay: 50,          ; çƒ­é”®å»¶è¿Ÿ
    HoldTime: 100,            ; æŒ‰ä½æ—¶é•¿
    Timestamp: 0,             ; æ—¶é—´æˆ³
    Parameters: {}            ; é¢å¤–å‚æ•°
}

; æŒ‰é”®å®šä¹‰
KeyBinding := {
    VKCode: 0,                ; è™šæ‹Ÿé”®ç 
    ScanCode: 0,              ; æ‰«æç 
    KeyName: "",              ; æŒ‰é”®åç§°
    Type: "normal",           ; æŒ‰é”®ç±»å‹
    IsExtended: false,        ; æ˜¯å¦æ‰©å±•é”®
    MouseButton: ""           ; é¼ æ ‡æŒ‰é”®
}
```

### æ ¸å¿ƒå‡½æ•°è¯¦è§£

#### ç¨‹åºå…¥å£

**ä¸»å‡½æ•°**
```autohotkey
; WorkerHostä¸»å‡½æ•°
#NoEnv
#SingleInstance Force
#Persistent
#MaxHotkeysPerInterval 99000000
#HotkeyInterval 99000000
#KeyHistory 0
ListLines Off
Process, Priority, , A
SetBatchLines -1
SetKeyDelay -1, -1
SetMouseDelay -1
SetDefaultMouseSpeed 0
SetWinDelay -1
SetControlDelay -1
SendMode Input

; è§£æå‘½ä»¤è¡Œå‚æ•°
args := {}
for index, param in A_Args {
    if (SubStr(param, 1, 2) == "--") {
        key := SubStr(param, 3)
        value := index + 1 <= A_Args.Length ? A_Args[index + 1] : "true"
        args[key] := value
    }
}

; åˆå§‹åŒ–WorkerHost
WorkerHost_Init(args)

; æ ¹æ®æ¨¡å¼å¯åŠ¨
if (args.Has("fire")) {
    ; ä¸€æ¬¡æ€§æ¨¡å¼
    WorkerHost_FireMode(args)
} else {
    ; å¸¸é©»æ¨¡å¼
    WorkerHost_PersistentMode()
}
```

#### ç³»ç»Ÿåˆå§‹åŒ–

**WorkerHost_Init()**
```autohotkey
; åˆå§‹åŒ–WorkerHost
WorkerHost_Init(args) {
    global WorkerHost
    
    try {
        ; è§£æé…ç½®å‚æ•°
        WorkerHost_ParseArgs(args)
        
        ; åˆ›å»ºçŠ¶æ€åé¦ˆçª—å£
        WorkerHost_CreateStatusWindow()
        
        ; åˆå§‹åŒ–æŒ‰é”®æ˜ å°„
        WorkerHost_InitKeyBindings()
        
        ; æ³¨å†Œæ¶ˆæ¯å¤„ç†
        WorkerHost_RegisterMessageHandlers()
        
        WorkerHost.IsReady := true
        WorkerHost_Log("WorkerHoståˆå§‹åŒ–å®Œæˆ")
        
        ; å‘é€å°±ç»ªæ¶ˆæ¯
        WorkerHost_SendReadyMessage()
    } catch error {
        WorkerHost_Log("WorkerHoståˆå§‹åŒ–å¤±è´¥: " error.message)
        ExitApp(1)
    }
}

; è§£æå‘½ä»¤è¡Œå‚æ•°
WorkerHost_ParseArgs(args) {
    global WorkerHost
    
    ; è®¾ç½®æ¨¡å¼
    if args.Has("fire") {
        WorkerHost.Mode := "fire"
    } else {
        WorkerHost.Mode := "persistent"
    }
    
    ; è·å–çˆ¶è¿›ç¨‹ID
    if args.Has("parent") {
        WorkerHost.ParentPID := Integer(args["parent"])
    }
    
    ; è¯»å–é…ç½®å‚æ•°
    if args.Has("delay") {
        WorkerHost.Config.HotkeyDelay := Integer(args["delay"])
    }
    
    if args.Has("hold") {
        WorkerHost.Config.HoldTime := Integer(args["hold"])
    }
    
    WorkerHost_Log("å‚æ•°è§£æå®Œæˆï¼Œæ¨¡å¼: " WorkerHost.Mode)
}
```

#### å¸¸é©»æ¨¡å¼

**WorkerHost_PersistentMode()**
```autohotkey
; å¸¸é©»æ¨¡å¼ä¸»å¾ªç¯
WorkerHost_PersistentMode() {
    global WorkerHost
    
    WorkerHost_Log("å¯åŠ¨å¸¸é©»æ¨¡å¼")
    
    ; å¯åŠ¨çŠ¶æ€ç›‘æ§
    SetTimer(WorkerHost_StatusMonitor, 1000)
    
    ; ä¸»æ¶ˆæ¯å¾ªç¯
    OnMessage(0x004A, WorkerHost_CopyDataHandler)  ; WM_COPYDATA
    OnExit(WorkerHost_OnExit)
    
    ; ç­‰å¾…æ¶ˆæ¯
    while (WorkerHost.Status != "shutdown") {
        Sleep(100)
        
        ; æ£€æŸ¥çˆ¶è¿›ç¨‹çŠ¶æ€
        if WorkerHost.ParentPID && !ProcessExist(WorkerHost.ParentPID) {
            WorkerHost_Log("çˆ¶è¿›ç¨‹å·²é€€å‡ºï¼ŒWorkerHostå°†å…³é—­")
            break
        }
    }
    
    WorkerHost_Log("å¸¸é©»æ¨¡å¼ç»“æŸ")
}

; WM_COPYDATAæ¶ˆæ¯å¤„ç†
WorkerHost_CopyDataHandler(wParam, lParam) {
    global WorkerHost
    
    try {
        ; è§£æCOPYDATASTRUCT
        pCopyData := lParam
        cbData := NumGet(pCopyData, 8, "Ptr")  ; cbDataå­—æ®µ
        
        ; è¯»å–æ•°æ®
        dataPtr := NumGet(pCopyData, 16, "Ptr")  ; lpDataå­—æ®µ
        data := StrGet(dataPtr, cbData, "UTF-8")
        
        ; è§£æJSONå‘½ä»¤
        command := JSON.Parse(data)
        
        ; æ‰§è¡Œå‘½ä»¤
        return WorkerHost_ExecuteCommand(command)
    } catch error {
        WorkerHost_Log("å‘½ä»¤å¤„ç†å¼‚å¸¸: " error.message)
        return 0
    }
}

; æ‰§è¡Œå‘½ä»¤
WorkerHost_ExecuteCommand(command) {
    global WorkerHost
    
    try {
        ; æ›´æ–°çŠ¶æ€
        WorkerHost.Status := "executing"
        WorkerHost.LastCommand := command
        
        ; æ ¹æ®å‘½ä»¤ç±»å‹æ‰§è¡Œ
        result := false
        
        switch command.Type {
            case "EXECUTE_SKILL":
                result := WorkerHost_ExecuteSkill(command)
            case "FIRE_AND_FORGET":
                result := WorkerHost_FireAndForget(command)
            case "PING":
                result := true
            case "GET_STATUS":
                result := WorkerHost_GetStatus()
            default:
                WorkerHost_Log("æœªçŸ¥å‘½ä»¤ç±»å‹: " command.Type)
        }
        
        ; æ›´æ–°çŠ¶æ€
        WorkerHost.Status := "idle"
        WorkerHost.LastExecution := A_TickCount
        
        ; å‘é€æ‰§è¡Œç»“æœ
        WorkerHost_SendResult(command, result)
        
        return result ? 1 : 0
    } catch error {
        WorkerHost.Status := "error"
        WorkerHost_Log("å‘½ä»¤æ‰§è¡Œå¼‚å¸¸: " error.message)
        WorkerHost_SendError(command, error.message)
        return 0
    }
}
```

#### ä¸€æ¬¡æ€§æ¨¡å¼

**WorkerHost_FireMode()**
```autohotkey
; ä¸€æ¬¡æ€§æ¨¡å¼æ‰§è¡Œ
WorkerHost_FireMode(args) {
    global WorkerHost
    
    try {
        WorkerHost_Log("å¯åŠ¨ä¸€æ¬¡æ€§æ¨¡å¼")
        
        ; è§£ææŠ€èƒ½ç´¢å¼•
        if !args.Has("skill") {
            WorkerHost_Log("ç¼ºå°‘æŠ€èƒ½å‚æ•°")
            ExitApp(1)
        }
        
        skillIndex := Integer(args["skill"])
        
        ; æ‰§è¡ŒæŠ€èƒ½
        result := WorkerHost_ExecuteSkill({
            Type: "EXECUTE_SKILL",
            SkillIndex: skillIndex,
            HotkeyDelay: WorkerHost.Config.HotkeyDelay,
            HoldTime: WorkerHost.Config.HoldTime
        })
        
        ; è¾“å‡ºç»“æœ
        if result {
            FileAppend("SUCCESS`n", "*")
            ExitApp(0)
        } else {
            FileAppend("FAILED`n", "*")
            ExitApp(1)
        }
    } catch error {
        WorkerHost_Log("ä¸€æ¬¡æ€§æ¨¡å¼å¼‚å¸¸: " error.message)
        FileAppend("ERROR: " error.message "`n", "*")
        ExitApp(1)
    }
}
```

#### æŠ€èƒ½æ‰§è¡Œ

**WorkerHost_ExecuteSkill()**
```autohotkey
; æ‰§è¡ŒæŠ€èƒ½
WorkerHost_ExecuteSkill(command) {
    global WorkerHost
    
    try {
        WorkerHost_Log("æ‰§è¡ŒæŠ€èƒ½: " command.SkillIndex)
        
        ; è·å–æŠ€èƒ½æŒ‰é”®ç»‘å®š
        keyBinding := WorkerHost_GetSkillBinding(command.SkillIndex)
        if !keyBinding {
            WorkerHost_Log("æœªæ‰¾åˆ°æŠ€èƒ½ç»‘å®š: " command.SkillIndex)
            return false
        }
        
        ; æ‰§è¡ŒæŒ‰é”®
        result := WorkerHost_SendKeyPress(keyBinding, command.HotkeyDelay, command.HoldTime)
        
        ; æ›´æ–°ç»Ÿè®¡
        WorkerHost.ExecutionCount++
        if result {
            WorkerHost.SuccessCount++
        }
        
        WorkerHost_Log("æŠ€èƒ½æ‰§è¡Œ" (result ? "æˆåŠŸ" : "å¤±è´¥") ": " command.SkillIndex)
        return result
    } catch error {
        WorkerHost_Log("æŠ€èƒ½æ‰§è¡Œå¼‚å¸¸: " error.message)
        return false
    }
}

; å‘é€æŒ‰é”®
WorkerHost_SendKeyPress(keyBinding, delay, holdTime) {
    try {
        ; æ ¹æ®æŒ‰é”®ç±»å‹æ‰§è¡Œä¸åŒçš„å‘é€é€»è¾‘
        if (keyBinding.Type == "mouse") {
            return WorkerHost_SendMousePress(keyBinding, delay, holdTime)
        } else if (keyBinding.Type == "function") {
            return WorkerHost_SendFunctionKey(keyBinding, delay, holdTime)
        } else {
            return WorkerHost_SendNormalKey(keyBinding, delay, holdTime)
        }
    } catch error {
        WorkerHost_Log("æŒ‰é”®å‘é€å¼‚å¸¸: " error.message)
        return false
    }
}

; å‘é€æ™®é€šæŒ‰é”®
WorkerHost_SendNormalKey(keyBinding, delay, holdTime) {
    try {
        ; å»¶è¿Ÿ
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; æŒ‰ä¸‹æŒ‰é”®
        Send("{" keyBinding.KeyName " down}")
        
        ; æŒ‰ä½æ—¶é•¿
        if (holdTime > 0) {
            Sleep(holdTime)
        }
        
        ; é‡Šæ”¾æŒ‰é”®
        Send("{" keyBinding.KeyName " up}")
        
        return true
    } catch error {
        WorkerHost_Log("æ™®é€šæŒ‰é”®å‘é€å¤±è´¥: " error.message)
        return false
    }
}

; å‘é€åŠŸèƒ½é”®
WorkerHost_SendFunctionKey(keyBinding, delay, holdTime) {
    try {
        ; åŠŸèƒ½é”®çš„ç‰¹æ®Šå¤„ç†
        ; å¯èƒ½éœ€è¦ä½¿ç”¨DllCallç›´æ¥å‘é€
        
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; å‘é€åŠŸèƒ½é”®
        switch keyBinding.KeyName {
            case "F1":
            case "F2":
            case "F3":
            case "F4":
                DllCall("keybd_event", "UChar", keyBinding.VKCode, "UChar", 0, "UInt", 0, "Ptr", 0)
                Sleep(holdTime)
                DllCall("keybd_event", "UChar", keyBinding.VKCode, "UChar", 0, "UInt", 2, "Ptr", 0)
            default:
                Send("{" keyBinding.KeyName " down}")
                Sleep(holdTime)
                Send("{" keyBinding.KeyName " up}")
        }
        
        return true
    } catch error {
        WorkerHost_Log("åŠŸèƒ½é”®å‘é€å¤±è´¥: " error.message)
        return false
    }
}

; å‘é€é¼ æ ‡æŒ‰é”®
WorkerHost_SendMousePress(keyBinding, delay, holdTime) {
    try {
        if (delay > 0) {
            Sleep(delay)
        }
        
        ; é¼ æ ‡æŒ‰é”®æ˜ å°„
        switch keyBinding.MouseButton {
            case "LButton":
                Send("{LButton down}")
                Sleep(holdTime)
                Send("{LButton up}")
            case "RButton":
                Send("{RButton down}")
                Sleep(holdTime)
                Send("{RButton up}")
            case "MButton":
                Send("{MButton down}")
                Sleep(holdTime)
                Send("{MButton up}")
            default:
                WorkerHost_Log("æœªçŸ¥é¼ æ ‡æŒ‰é”®: " keyBinding.MouseButton)
                return false
        }
        
        return true
    } catch error {
        WorkerHost_Log("é¼ æ ‡æŒ‰é”®å‘é€å¤±è´¥: " error.message)
        return false
    }
}
```

#### æŒ‰é”®æ˜ å°„

**WorkerHost_GetSkillBinding()**
```autohotkey
; è·å–æŠ€èƒ½ç»‘å®š
WorkerHost_GetSkillBinding(skillIndex) {
    global WorkerHost
    
    ; ä»é…ç½®æ–‡ä»¶æˆ–å†…ç½®æ˜ å°„è·å–
    ; è¿™é‡Œæä¾›ä¸€äº›ç¤ºä¾‹æ˜ å°„
    skillMappings := {
        1: { KeyName: "1", Type: "normal", VKCode: 0x31 },
        2: { KeyName: "2", Type: "normal", VKCode: 0x32 },
        3: { KeyName: "3", Type: "normal", VKCode: 0x33 },
        4: { KeyName: "4", Type: "normal", VKCode: 0x34 },
        5: { KeyName: "5", Type: "normal", VKCode: 0x35 },
        "F1": { KeyName: "F1", Type: "function", VKCode: 0x70 },
        "F2": { KeyName: "F2", Type: "function", VKCode: 0x71 },
        "F3": { KeyName: "F3", Type: "function", VKCode: 0x72 },
        "F4": { KeyName: "F4", Type: "function", VKCode: 0x73 },
        "LButton": { MouseButton: "LButton", Type: "mouse" },
        "RButton": { MouseButton: "RButton", Type: "mouse" }
    }
    
    return skillMappings.Has(skillIndex) ? skillMappings[skillIndex] : false
}
```

#### è¿›ç¨‹é€šä¿¡

**WorkerHost_SendResult()**
```autohotkey
; å‘é€æ‰§è¡Œç»“æœ
WorkerHost_SendResult(command, success) {
    try {
        result := {
            Type: "EXECUTION_RESULT",
            CommandID: command.Timestamp,
            SkillIndex: command.SkillIndex,
            ThreadID: command.ThreadID,
            Success: success,
            ExecutionTime: A_TickCount - command.Timestamp,
            Timestamp: A_TickCount
        }
        
        resultJSON := JSON.Stringify(result)
        
        ; å‘é€åˆ°çˆ¶è¿›ç¨‹
        if (WorkerHost.ParentPID) {
            WorkerHost_SendToParent(resultJSON)
        }
    } catch error {
        WorkerHost_Log("å‘é€ç»“æœå¤±è´¥: " error.message)
    }
}

; å‘é€åˆ°çˆ¶è¿›ç¨‹
WorkerHost_SendToParent(data) {
    try {
        ; æŸ¥æ‰¾çˆ¶è¿›ç¨‹çª—å£
        parentHWND := WorkerHost_FindParentWindow()
        
        if (parentHWND) {
            ; ä½¿ç”¨WM_COPYDATAå‘é€
            copyDataStruct := WorkerHost_CreateCopyDataStruct(data)
            DllCall("SendMessageW"
                , "Ptr", parentHWND
                , "UInt", 0x004A  ; WM_COPYDATA
                , "Ptr", 0        ; wParam
                , "Ptr", copyDataStruct
                , "Ptr")
        }
    } catch error {
        WorkerHost_Log("å‘é€åˆ°çˆ¶è¿›ç¨‹å¤±è´¥: " error.message)
    }
}

; åˆ›å»ºCOPYDATASTRUCT
WorkerHost_CreateCopyDataStruct(data) {
    dataSize := (StrLen(data) + 1) * 2  ; UTF-16å­—ç¬¦å¤§å°
    
    ; åˆ†é…å†…å­˜
    buffer := Buffer(24 + dataSize, 0)  ; COPYDATASTRUCTå¤§å° + æ•°æ®
    pBuffer := buffer.Ptr
    
    ; å¡«å……ç»“æ„
    NumPut("Ptr", 0x004A, pBuffer)                    ; dwData (æ¶ˆæ¯ç±»å‹)
    NumPut("Int", dataSize, pBuffer + 8)              ; cbData
    NumPut("Ptr", pBuffer + 24, pBuffer + 8)          ; lpData (æŒ‡å‘æ•°æ®åŒº)
    
    ; å†™å…¥æ•°æ®
    StrPut(data, pBuffer + 24, "UTF-16")
    
    return buffer
}
```

#### çŠ¶æ€ç›‘æ§

**WorkerHost_StatusMonitor()**
```autohotkey
; çŠ¶æ€ç›‘æ§
WorkerHost_StatusMonitor() {
    global WorkerHost
    
    try {
        ; æ›´æ–°çŠ¶æ€çª—å£
        WorkerHost_UpdateStatusWindow()
        
        ; æ¸…ç†è¿‡æœŸæ•°æ®
        WorkerHost_CleanupOldData()
        
        ; æ£€æŸ¥é”™è¯¯çŠ¶æ€
        WorkerHost_CheckErrorState()
    } catch error {
        ; å¿½ç•¥ç›‘æ§é”™è¯¯ï¼Œé¿å…å½±å“ä¸»åŠŸèƒ½
    }
}

; æ›´æ–°çŠ¶æ€çª—å£
WorkerHost_UpdateStatusWindow() {
    global WorkerHost
    
    if WorkerHost.StatusWindow {
        ; æ›´æ–°æ˜¾ç¤ºå†…å®¹
        statusText := "WorkerHostçŠ¶æ€:`n"
        statusText .= "æ¨¡å¼: " WorkerHost.Mode "`n"
        statusText .= "çŠ¶æ€: " WorkerHost.Status "`n"
        statusText .= "æ‰§è¡Œæ¬¡æ•°: " WorkerHost.ExecutionCount "`n"
        statusText .= "æˆåŠŸç‡: " Round(WorkerHost.SuccessCount / Max(1, WorkerHost.ExecutionCount) * 100, 2) "%`n"
        statusText .= "æœ€åæ‰§è¡Œ: " (WorkerHost.LastExecution ? Round((A_TickCount - WorkerHost.LastExecution) / 1000, 1) "ç§’å‰" : "æ— ")
        
        ; æ›´æ–°æ§ä»¶
        GuiControl, WorkerHost.StatusWindow:, WorkerHost.StatusText, %statusText%
    }
}
```

## 3. çƒ­é”®ç®¡ç† - Hotkeys.ahk

### æ ¸å¿ƒåŠŸèƒ½

Hotkeysæ¨¡å—æä¾›çƒ­é”®ç»‘å®šå’ŒçŠ¶æ€åˆ‡æ¢åŠŸèƒ½ï¼Œæ”¯æŒå¯åŠ¨/åœæ­¢çƒ­é”®ã€æŒ‰é”®ç©¿é€ç­‰ç‰¹æ€§ã€‚

**ä¸»è¦ç‰¹æ€§**:
- **å¯åŠ¨çƒ­é”®**: ç»‘å®šå¼€å§‹/åœæ­¢å®çš„çƒ­é”®
- **é¼ æ ‡æŒ‰é”®æ”¯æŒ**: è‡ªåŠ¨ä¸ºé¼ æ ‡æŒ‰é”®æ·»åŠ ç©¿é€å‰ç¼€
- **çŠ¶æ€åˆ‡æ¢**: åˆ‡æ¢å®è¿è¡ŒçŠ¶æ€
- **çƒ­é”®å»¶è¿Ÿ**: å¯é…ç½®çš„çƒ­é”®æ‰§è¡Œå»¶è¿Ÿ
- **æŒ‰é”®ç©¿é€**: æ”¯æŒç‰¹æ®ŠæŒ‰é”®çš„ç©¿é€åŠŸèƒ½

### æ ¸å¿ƒå‡½æ•°è¯¦è§£

#### å¯åŠ¨çƒ­é”®ç»‘å®š

**Hotkeys_BindStartHotkey()**
```autohotkey
; ç»‘å®šå¯åŠ¨çƒ­é”®
Hotkeys_BindStartHotkey(hotkey, callback) {
    try {
        ; æ£€æŸ¥æ˜¯å¦ä¸ºé¼ æ ‡æŒ‰é”®
        isMouseKey := Hotkeys_IsMouseKey(hotkey)
        
        modifiedHotkey := hotkey
        
        ; ä¸ºé¼ æ ‡æŒ‰é”®æ·»åŠ ç©¿é€å‰ç¼€
        if (isMouseKey) {
            modifiedHotkey := Hotkeys_AddPassThroughPrefix(hotkey)
        }
        
        ; ç»‘å®šçƒ­é”®
        try {
            Hotkey(modifiedHotkey, callback, "On")
            
            Hotkeys_Log("çƒ­é”®ç»‘å®šæˆåŠŸ: " hotkey " -> " modifiedHotkey)
            return true
        } catch error {
            Hotkeys_Log("çƒ­é”®ç»‘å®šå¤±è´¥: " hotkey " - " error.message)
            return false
        }
    } catch error {
        Hotkeys_Log("ç»‘å®šçƒ­é”®å¼‚å¸¸: " error.message)
        return false
    }
}

; æ£€æŸ¥æ˜¯å¦ä¸ºé¼ æ ‡æŒ‰é”®
Hotkeys_IsMouseKey(hotkey) {
    mouseKeys := ["LButton", "RButton", "MButton", "XButton1", "XButton2"]
    
    for key in mouseKeys {
        if InStr(hotkey, key) {
            return true
        }
    }
    
    return false
}

; æ·»åŠ ç©¿é€å‰ç¼€
Hotkeys_AddPassThroughPrefix(hotkey) {
    ; AutoHotkeyçš„é¼ æ ‡æŒ‰é”®ç©¿é€è¯­æ³•
    ; $ å‰ç¼€é˜²æ­¢çƒ­é”®é€’å½’è§¦å‘
    return "$" hotkey
}
```

#### çŠ¶æ€åˆ‡æ¢

**Hotkeys_ToggleRunning()**
```autohotkey
; åˆ‡æ¢è¿è¡ŒçŠ¶æ€
Hotkeys_ToggleRunning() {
    global IsRunning
    
    if (IsRunning) {
        ; åœæ­¢è¿è¡Œ
        IsRunning := false
        Hotkeys_Log("å®å·²åœæ­¢")
        Hotkeys_UpdateTrayStatus("å·²åœæ­¢")
    } else {
        ; å¼€å§‹è¿è¡Œ
        IsRunning := true
        Hotkeys_Log("å®å·²å¼€å§‹")
        Hotkeys_UpdateTrayStatus("è¿è¡Œä¸­")
        
        ; å¯åŠ¨ä¸»å¾ªç¯
        SetTimer(MainLoop, 50)
    }
    
    ; é€šçŸ¥UIæ›´æ–°
    if (UI.MainWindow) {
        PostMessage(0x1001, IsRunning ? 1 : 0)  ; è‡ªå®šä¹‰æ¶ˆæ¯
    }
}

; æ›´æ–°æ‰˜ç›˜çŠ¶æ€
Hotkeys_UpdateTrayStatus(status) {
    try {
        ; æ›´æ–°æ‰˜ç›˜èœå•æ–‡æœ¬
        ; è¿™é‡Œéœ€è¦å…·ä½“çš„æ‰˜ç›˜èœå•æ›´æ–°é€»è¾‘
        Menu, Tray, Text, Game Macro [%status%]
    } catch {
        ; å¿½ç•¥æ›´æ–°å¤±è´¥
    }
}
```

#### çƒ­é”®æ‰§è¡Œ

**Hotkeys_ExecuteStartCommand()**
```autohotkey
; æ‰§è¡Œå¯åŠ¨å‘½ä»¤
Hotkeys_ExecuteStartCommand() {
    try {
        ; å»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…ä¸æ¸¸æˆçƒ­é”®å†²çª
        Sleep(50)
        
        ; æ‰§è¡ŒçŠ¶æ€åˆ‡æ¢
        Hotkeys_ToggleRunning()
        
        ; æ‰§è¡Œç»“æœåé¦ˆ
        Hotkeys_FeedbackExecution()
        
    } catch error {
        Hotkeys_Log("å¯åŠ¨å‘½ä»¤æ‰§è¡Œå¼‚å¸¸: " error.message)
    }
}

; æ‰§è¡Œç»“æœåé¦ˆ
Hotkeys_FeedbackExecution() {
    try {
        ; æ˜¾ç¤ºæ‰§è¡Œåé¦ˆï¼ˆå¯é€‰ï¼‰
        ; å‘é€ä¿¡å·ç»™ä¸»ç¨‹åº
        if (WorkerPool.Status == "running") {
            ; å‘é€åˆ‡æ¢æˆåŠŸçš„ä¿¡å·
            ; è¿™é‡Œå¯ä»¥å‘é€ç‰¹å®šçš„ä¿¡å·æˆ–æ¶ˆæ¯
        }
    } catch {
        ; å¿½ç•¥åé¦ˆå¤±è´¥
    }
}
```

## 4. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### è¿›ç¨‹æ± ä¼˜åŒ–

**æ™ºèƒ½è¿›ç¨‹ç®¡ç†**:
```autohotkey
; è¿›ç¨‹æ± åŠ¨æ€è°ƒæ•´
WorkerPool_OptimizeProcessPool() {
    global WorkerPool
    
    ; æ ¹æ®ç³»ç»Ÿè´Ÿè½½è°ƒæ•´Workeræ•°é‡
    systemLoad := WorkerPool_GetSystemLoad()
    optimalWorkers := WorkerPool_CalculateOptimalWorkerCount(systemLoad)
    
    currentWorkers := WorkerPool.Workers.Count()
    
    if (currentWorkers < optimalWorkers) {
        ; å¢åŠ Worker
        while (currentWorkers < optimalWorkers) {
            WorkerPool_CreateWorker()
            currentWorkers++
        }
    } else if (currentWorkers > optimalWorkers) {
        ; å‡å°‘Worker
        WorkerPool_ReduceExcessWorkers(currentWorkers - optimalWorkers)
    }
}
```

### å†…å­˜ç®¡ç†

**å†…å­˜ä¼˜åŒ–**:
```autohotkey
; å†…å­˜æ¸…ç†
WorkerPool_CleanupMemory() {
    ; æ¸…ç†è¿‡æœŸçš„é”è®°å½•
    WorkerPool_CleanupExpiredLocks()
    
    ; æ¸…ç†å†å²è®°å½•
    if (WorkerPool.LockManager.LockHistory.Length > 100) {
        WorkerPool.LockManager.LockHistory.RemoveAt(1, 50)
    }
    
    ; å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
    try {
        ; è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„å†…å­˜ç®¡ç†è°ƒç”¨
    } catch {
        ; å¿½ç•¥æ¸…ç†å¼‚å¸¸
    }
}
```

### å»¶è¿Ÿä¼˜åŒ–

**å»¶è¿Ÿç®¡ç†**:
```autohotkey
; æ™ºèƒ½å»¶è¿Ÿè°ƒæ•´
WorkerPool_AdjustDynamicDelay() {
    global WorkerPool
    
    ; æ ¹æ®æ‰§è¡ŒæˆåŠŸç‡è°ƒæ•´å»¶è¿Ÿ
    successRate := WorkerPool.Performance.SuccessRate
    
    if (successRate < 0.8) {
        ; æˆåŠŸç‡ä½ï¼Œå¢åŠ å»¶è¿Ÿ
        WorkerPool.Config.HotkeyDelay := Min(WorkerPool.Config.HotkeyDelay + 10, 200)
    } else if (successRate > 0.95) {
        ; æˆåŠŸç‡é«˜ï¼Œå¯ä»¥å‡å°‘å»¶è¿Ÿ
        WorkerPool.Config.HotkeyDelay := Max(WorkerPool.Config.HotkeyDelay - 5, 20)
    }
}
```

## 5. é”™è¯¯å¤„ç†ä¸æ¢å¤

### é”™è¯¯å¤„ç†æœºåˆ¶

**å…¨å±€é”™è¯¯å¤„ç†**:
```autohotkey
; å·¥ä½œæ± é”™è¯¯å¤„ç†
WorkerPool_HandleError(error, context) {
    global WorkerPool
    
    ; è®°å½•é”™è¯¯
    WorkerPool_Log("é”™è¯¯ [" context "]: " error.message)
    
    ; åˆ†ç±»å¤„ç†ä¸åŒç±»å‹çš„é”™è¯¯
    if InStr(error.message, "è¿›ç¨‹") {
        WorkerPool_HandleProcessError(error)
    } else if InStr(error.message, "å†…å­˜") {
        WorkerPool_HandleMemoryError(error)
    } else {
        WorkerPool_HandleGeneralError(error)
    }
    
    ; æ›´æ–°é”™è¯¯ç»Ÿè®¡
    WorkerPool.Performance.ErrorCount++
}

; è¿›ç¨‹é”™è¯¯å¤„ç†
WorkerPool_HandleProcessError(error) {
    ; é‡å¯å¤±è´¥çš„Workerè¿›ç¨‹
    ; é‡æ–°åˆ†é…ä»»åŠ¡
    ; æ›´æ–°è¿›ç¨‹å¥åº·çŠ¶æ€
}

; å†…å­˜é”™è¯¯å¤„ç†  
WorkerPool_HandleMemoryError(error) {
    ; æ¸…ç†å†…å­˜ç¼“å­˜
    WorkerPool_CleanupMemory()
    
    ; å‡å°‘Workeræ•°é‡
    if (WorkerPool.Workers.Count() > 2) {
        WorkerPool_ReduceWorkers(1)
    }
}
```

### è‡ªåŠ¨æ¢å¤æœºåˆ¶

**æ¢å¤ç­–ç•¥**:
```autohotkey
; è‡ªåŠ¨æ¢å¤
WorkerPool_AutoRecover() {
    global WorkerPool
    
    try {
        ; æ£€æŸ¥å¹¶é‡å¯å´©æºƒçš„Worker
        WorkerPool_RestartDeadWorkers()
        
        ; é‡æ–°åˆ†é…æœªå®Œæˆçš„ä»»åŠ¡
        WorkerPool_ReassignPendingTasks()
        
        ; æ¸…ç†æŸåçš„çŠ¶æ€
        WorkerPool_CleanupCorruptedState()
        
        WorkerPool_Log("è‡ªåŠ¨æ¢å¤å®Œæˆ")
        return true
    } catch error {
        WorkerPool_Log("è‡ªåŠ¨æ¢å¤å¤±è´¥: " error.message)
        return false
    }
}
```

## 6. é…ç½®ç®¡ç†

### å·¥ä½œæ± é…ç½®

**é…ç½®é¡¹è¯´æ˜**:
```autohotkey
; å·¥ä½œæ± é…ç½®ç»“æ„
WorkerPool_Config := {
    FFOnlyMode: true,          // FF-ONLYæ¨¡å¼
    MaxWorkers: 4,            // æœ€å¤§Workeræ•°é‡
    AutoScale: true,          // è‡ªåŠ¨æ‰©ç¼©å®¹
    HotkeyDelay: 50,          // çƒ­é”®å»¶è¿Ÿ(æ¯«ç§’)
    HoldTime: 100,            // æŒ‰ä½æ—¶é•¿(æ¯«ç§’)
    LockTimeout: 30000,       // é”è¶…æ—¶æ—¶é—´
    HealthCheckInterval: 5000, // å¥åº·æ£€æŸ¥é—´éš”
    PerformanceUpdateInterval: 1000, // æ€§èƒ½æ›´æ–°é—´éš”
    RetryCount: 3,            // é‡è¯•æ¬¡æ•°
    QueueSize: 100,           // é˜Ÿåˆ—å¤§å°é™åˆ¶
    LoadThreshold: {          // è´Ÿè½½é˜ˆå€¼
        ScaleUp: 0.8,         // æ‰©å®¹é˜ˆå€¼
        ScaleDown: 0.2        // ç¼©å®¹é˜ˆå€¼
    }
}
```

### é…ç½®åŠ è½½

**é…ç½®ç®¡ç†**:
```autohotkey
; åŠ è½½å·¥ä½œæ± é…ç½®
WorkerPool_LoadConfig() {
    global WorkerPool
    
    ; ä»AppConfig.iniè¯»å–
    WorkerPool.Config.MaxWorkers := AppConfig_GetPerformanceSetting("MaxWorkers", 4)
    WorkerPool.Config.HotkeyDelay := AppConfig_GetPerformanceSetting("HotkeyDelay", 50)
    WorkerPool.Config.HoldTime := AppConfig_GetPerformanceSetting("HoldTime", 100)
    WorkerPool.Config.AutoScale := AppConfig_GetPerformanceSetting("AutoScale", true)
    
    ; éªŒè¯é…ç½®
    WorkerPool_ValidateConfig()
}

; é…ç½®éªŒè¯
WorkerPool_ValidateConfig() {
    global WorkerPool
    
    ; ç¡®ä¿é…ç½®åœ¨åˆç†èŒƒå›´å†…
    WorkerPool.Config.MaxWorkers := Max(1, Min(16, WorkerPool.Config.MaxWorkers))
    WorkerPool.Config.HotkeyDelay := Max(0, Min(1000, WorkerPool.Config.HotkeyDelay))
    WorkerPool.Config.HoldTime := Max(0, Min(5000, WorkerPool.Config.HoldTime))
    
    WorkerPool_Log("é…ç½®éªŒè¯å®Œæˆ")
}
```

## æ€»ç»“

å·¥ä½œæ± ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„é«˜æ€§èƒ½ä»»åŠ¡æ‰§è¡Œè§£å†³æ–¹æ¡ˆï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

**æ ¸å¿ƒä¼˜åŠ¿**:
- âœ… FF-ONLYæ¨¡å¼ä¸“é—¨ä¼˜åŒ–ï¼Œé€‚åˆæ¸¸æˆåœºæ™¯
- âœ… æ™ºèƒ½æ–½æ³•é”æœºåˆ¶ï¼Œé¿å…æŠ€èƒ½å†²çª
- âœ… å¤šè¿›ç¨‹å¹¶å‘æ‰§è¡Œï¼Œæå‡æ‰§è¡Œæ•ˆç‡
- âœ… å®Œå–„çš„æ€§èƒ½ç›‘æ§å’Œè‡ªåŠ¨ä¼˜åŒ–
- âœ… å¼ºå¤§çš„é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨æ¢å¤
- âœ… çµæ´»çš„çƒ­é”®ç®¡ç†å’ŒæŒ‰é”®æ˜ å°„

**æŠ€æœ¯ç‰¹æ€§**:
- **è¿›ç¨‹æ± ç®¡ç†**: åŠ¨æ€è¿›ç¨‹åˆ›å»ºã€é”€æ¯å’Œè´Ÿè½½å‡è¡¡
- **é€šä¿¡æœºåˆ¶**: é«˜æ•ˆçš„WM_COPYDATAè¿›ç¨‹é—´é€šä¿¡
- **é”ç®¡ç†**: åŸºäºçº¿ç¨‹IDçš„æ™ºèƒ½é”æœºåˆ¶
- **æ€§èƒ½ä¼˜åŒ–**: å®æ—¶æ€§èƒ½ç›‘æ§å’Œè‡ªåŠ¨è°ƒä¼˜
- **é”™è¯¯æ¢å¤**: è‡ªåŠ¨é”™è¯¯æ£€æµ‹å’Œæ¢å¤æœºåˆ¶
- **é…ç½®çµæ´»**: ä¸°å¯Œçš„é…ç½®é€‰é¡¹å’Œå®æ—¶æ›´æ–°

**åº”ç”¨ä»·å€¼**:
- ä¸ºGame Macroæä¾›ç¨³å®šå¯é çš„ä»»åŠ¡æ‰§è¡Œå¼•æ“
- æ”¯æŒé«˜å¹¶å‘çš„æŠ€èƒ½æ‰§è¡Œå’ŒçŠ¶æ€ç®¡ç†
- æä¾›æ™ºèƒ½çš„è´Ÿè½½å‡è¡¡å’Œèµ„æºä¼˜åŒ–
- å®ç°å®Œå–„çš„ç›‘æ§ã€æ—¥å¿—å’Œè°ƒè¯•æ”¯æŒ
- æ”¯æŒå¤šç§æ‰§è¡Œæ¨¡å¼å’Œçµæ´»çš„é…ç½®ç®¡ç†

**æ‰©å±•å»ºè®®**:
- å¢åŠ æ›´å¤šé€šä¿¡åè®®æ”¯æŒï¼ˆå‘½åç®¡é“ã€å…±äº«å†…å­˜ï¼‰
- å®ç°æ›´æ™ºèƒ½çš„é¢„æµ‹æ€§è´Ÿè½½å‡è¡¡
- æ·»åŠ GPUåŠ é€Ÿæ”¯æŒï¼ˆå¦‚é€‚ç”¨ï¼‰
- å®ç°åˆ†å¸ƒå¼å·¥ä½œæ± æ”¯æŒ
- å¢åŠ æ›´å¤šçš„æ€§èƒ½åˆ†æå·¥å…·å’Œå¯è§†åŒ–ç•Œé¢

---

*ğŸ“ æœ€åæ›´æ–°: 2025-11-29*  
*ğŸ”„ æ–‡æ¡£ç‰ˆæœ¬: v1.1*  
*ğŸ‘¨â€ğŸ’» ç»´æŠ¤å›¢é˜Ÿ: Game Macroå¼€å‘ç»„*